// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/main/protobuf/analysis_v2.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.ActionGraphContainer)
pub struct ActionGraphContainer {
    // message fields
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.artifacts)
    pub artifacts: ::std::vec::Vec<Artifact>,
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.actions)
    pub actions: ::std::vec::Vec<Action>,
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.targets)
    pub targets: ::std::vec::Vec<Target>,
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.dep_set_of_files)
    pub dep_set_of_files: ::std::vec::Vec<DepSetOfFiles>,
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.configuration)
    pub configuration: ::std::vec::Vec<Configuration>,
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.aspect_descriptors)
    pub aspect_descriptors: ::std::vec::Vec<AspectDescriptor>,
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.rule_classes)
    pub rule_classes: ::std::vec::Vec<RuleClass>,
    // @@protoc_insertion_point(field:analysis.ActionGraphContainer.path_fragments)
    pub path_fragments: ::std::vec::Vec<PathFragment>,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.ActionGraphContainer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionGraphContainer {
    fn default() -> &'a ActionGraphContainer {
        <ActionGraphContainer as ::protobuf::Message>::default_instance()
    }
}

impl ActionGraphContainer {
    pub fn new() -> ActionGraphContainer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "artifacts",
            |m: &ActionGraphContainer| { &m.artifacts },
            |m: &mut ActionGraphContainer| { &mut m.artifacts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &ActionGraphContainer| { &m.actions },
            |m: &mut ActionGraphContainer| { &mut m.actions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "targets",
            |m: &ActionGraphContainer| { &m.targets },
            |m: &mut ActionGraphContainer| { &mut m.targets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dep_set_of_files",
            |m: &ActionGraphContainer| { &m.dep_set_of_files },
            |m: &mut ActionGraphContainer| { &mut m.dep_set_of_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "configuration",
            |m: &ActionGraphContainer| { &m.configuration },
            |m: &mut ActionGraphContainer| { &mut m.configuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "aspect_descriptors",
            |m: &ActionGraphContainer| { &m.aspect_descriptors },
            |m: &mut ActionGraphContainer| { &mut m.aspect_descriptors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rule_classes",
            |m: &ActionGraphContainer| { &m.rule_classes },
            |m: &mut ActionGraphContainer| { &mut m.rule_classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "path_fragments",
            |m: &ActionGraphContainer| { &m.path_fragments },
            |m: &mut ActionGraphContainer| { &mut m.path_fragments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionGraphContainer>(
            "ActionGraphContainer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionGraphContainer {
    const NAME: &'static str = "ActionGraphContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.artifacts.push(is.read_message()?);
                },
                18 => {
                    self.actions.push(is.read_message()?);
                },
                26 => {
                    self.targets.push(is.read_message()?);
                },
                34 => {
                    self.dep_set_of_files.push(is.read_message()?);
                },
                42 => {
                    self.configuration.push(is.read_message()?);
                },
                50 => {
                    self.aspect_descriptors.push(is.read_message()?);
                },
                58 => {
                    self.rule_classes.push(is.read_message()?);
                },
                66 => {
                    self.path_fragments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.artifacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dep_set_of_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.configuration {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.aspect_descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rule_classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.path_fragments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.artifacts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.targets {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.dep_set_of_files {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.configuration {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.aspect_descriptors {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.rule_classes {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.path_fragments {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionGraphContainer {
        ActionGraphContainer::new()
    }

    fn clear(&mut self) {
        self.artifacts.clear();
        self.actions.clear();
        self.targets.clear();
        self.dep_set_of_files.clear();
        self.configuration.clear();
        self.aspect_descriptors.clear();
        self.rule_classes.clear();
        self.path_fragments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionGraphContainer {
        static instance: ActionGraphContainer = ActionGraphContainer {
            artifacts: ::std::vec::Vec::new(),
            actions: ::std::vec::Vec::new(),
            targets: ::std::vec::Vec::new(),
            dep_set_of_files: ::std::vec::Vec::new(),
            configuration: ::std::vec::Vec::new(),
            aspect_descriptors: ::std::vec::Vec::new(),
            rule_classes: ::std::vec::Vec::new(),
            path_fragments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionGraphContainer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionGraphContainer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionGraphContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionGraphContainer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.Artifact)
pub struct Artifact {
    // message fields
    // @@protoc_insertion_point(field:analysis.Artifact.id)
    pub id: u32,
    // @@protoc_insertion_point(field:analysis.Artifact.path_fragment_id)
    pub path_fragment_id: u32,
    // @@protoc_insertion_point(field:analysis.Artifact.is_tree_artifact)
    pub is_tree_artifact: bool,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.Artifact.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Artifact {
    fn default() -> &'a Artifact {
        <Artifact as ::protobuf::Message>::default_instance()
    }
}

impl Artifact {
    pub fn new() -> Artifact {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Artifact| { &m.id },
            |m: &mut Artifact| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path_fragment_id",
            |m: &Artifact| { &m.path_fragment_id },
            |m: &mut Artifact| { &mut m.path_fragment_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_tree_artifact",
            |m: &Artifact| { &m.is_tree_artifact },
            |m: &mut Artifact| { &mut m.is_tree_artifact },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Artifact>(
            "Artifact",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Artifact {
    const NAME: &'static str = "Artifact";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                16 => {
                    self.path_fragment_id = is.read_uint32()?;
                },
                24 => {
                    self.is_tree_artifact = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if self.path_fragment_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.path_fragment_id);
        }
        if self.is_tree_artifact != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.path_fragment_id != 0 {
            os.write_uint32(2, self.path_fragment_id)?;
        }
        if self.is_tree_artifact != false {
            os.write_bool(3, self.is_tree_artifact)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Artifact {
        Artifact::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path_fragment_id = 0;
        self.is_tree_artifact = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Artifact {
        static instance: Artifact = Artifact {
            id: 0,
            path_fragment_id: 0,
            is_tree_artifact: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Artifact {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Artifact").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Artifact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Artifact {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.Action)
pub struct Action {
    // message fields
    // @@protoc_insertion_point(field:analysis.Action.target_id)
    pub target_id: u32,
    // @@protoc_insertion_point(field:analysis.Action.aspect_descriptor_ids)
    pub aspect_descriptor_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:analysis.Action.action_key)
    pub action_key: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Action.mnemonic)
    pub mnemonic: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Action.configuration_id)
    pub configuration_id: u32,
    // @@protoc_insertion_point(field:analysis.Action.arguments)
    pub arguments: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:analysis.Action.environment_variables)
    pub environment_variables: ::std::vec::Vec<KeyValuePair>,
    // @@protoc_insertion_point(field:analysis.Action.input_dep_set_ids)
    pub input_dep_set_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:analysis.Action.output_ids)
    pub output_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:analysis.Action.discovers_inputs)
    pub discovers_inputs: bool,
    // @@protoc_insertion_point(field:analysis.Action.execution_info)
    pub execution_info: ::std::vec::Vec<KeyValuePair>,
    // @@protoc_insertion_point(field:analysis.Action.param_files)
    pub param_files: ::std::vec::Vec<ParamFile>,
    // @@protoc_insertion_point(field:analysis.Action.primary_output_id)
    pub primary_output_id: u32,
    // @@protoc_insertion_point(field:analysis.Action.execution_platform)
    pub execution_platform: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Action.template_content)
    pub template_content: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Action.substitutions)
    pub substitutions: ::std::vec::Vec<KeyValuePair>,
    // @@protoc_insertion_point(field:analysis.Action.file_contents)
    pub file_contents: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.Action.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Action {
    fn default() -> &'a Action {
        <Action as ::protobuf::Message>::default_instance()
    }
}

impl Action {
    pub fn new() -> Action {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_id",
            |m: &Action| { &m.target_id },
            |m: &mut Action| { &mut m.target_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "aspect_descriptor_ids",
            |m: &Action| { &m.aspect_descriptor_ids },
            |m: &mut Action| { &mut m.aspect_descriptor_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action_key",
            |m: &Action| { &m.action_key },
            |m: &mut Action| { &mut m.action_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mnemonic",
            |m: &Action| { &m.mnemonic },
            |m: &mut Action| { &mut m.mnemonic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "configuration_id",
            |m: &Action| { &m.configuration_id },
            |m: &mut Action| { &mut m.configuration_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &Action| { &m.arguments },
            |m: &mut Action| { &mut m.arguments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "environment_variables",
            |m: &Action| { &m.environment_variables },
            |m: &mut Action| { &mut m.environment_variables },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_dep_set_ids",
            |m: &Action| { &m.input_dep_set_ids },
            |m: &mut Action| { &mut m.input_dep_set_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_ids",
            |m: &Action| { &m.output_ids },
            |m: &mut Action| { &mut m.output_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "discovers_inputs",
            |m: &Action| { &m.discovers_inputs },
            |m: &mut Action| { &mut m.discovers_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "execution_info",
            |m: &Action| { &m.execution_info },
            |m: &mut Action| { &mut m.execution_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "param_files",
            |m: &Action| { &m.param_files },
            |m: &mut Action| { &mut m.param_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "primary_output_id",
            |m: &Action| { &m.primary_output_id },
            |m: &mut Action| { &mut m.primary_output_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "execution_platform",
            |m: &Action| { &m.execution_platform },
            |m: &mut Action| { &mut m.execution_platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "template_content",
            |m: &Action| { &m.template_content },
            |m: &mut Action| { &mut m.template_content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "substitutions",
            |m: &Action| { &m.substitutions },
            |m: &mut Action| { &mut m.substitutions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_contents",
            |m: &Action| { &m.file_contents },
            |m: &mut Action| { &mut m.file_contents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Action>(
            "Action",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Action {
    const NAME: &'static str = "Action";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_id = is.read_uint32()?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.aspect_descriptor_ids)?;
                },
                16 => {
                    self.aspect_descriptor_ids.push(is.read_uint32()?);
                },
                26 => {
                    self.action_key = is.read_string()?;
                },
                34 => {
                    self.mnemonic = is.read_string()?;
                },
                40 => {
                    self.configuration_id = is.read_uint32()?;
                },
                50 => {
                    self.arguments.push(is.read_string()?);
                },
                58 => {
                    self.environment_variables.push(is.read_message()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.input_dep_set_ids)?;
                },
                64 => {
                    self.input_dep_set_ids.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.output_ids)?;
                },
                72 => {
                    self.output_ids.push(is.read_uint32()?);
                },
                80 => {
                    self.discovers_inputs = is.read_bool()?;
                },
                90 => {
                    self.execution_info.push(is.read_message()?);
                },
                98 => {
                    self.param_files.push(is.read_message()?);
                },
                104 => {
                    self.primary_output_id = is.read_uint32()?;
                },
                114 => {
                    self.execution_platform = is.read_string()?;
                },
                122 => {
                    self.template_content = is.read_string()?;
                },
                130 => {
                    self.substitutions.push(is.read_message()?);
                },
                138 => {
                    self.file_contents = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.target_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.target_id);
        }
        for value in &self.aspect_descriptor_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if !self.action_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action_key);
        }
        if !self.mnemonic.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mnemonic);
        }
        if self.configuration_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.configuration_id);
        }
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.environment_variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.input_dep_set_ids {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.output_ids {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if self.discovers_inputs != false {
            my_size += 1 + 1;
        }
        for value in &self.execution_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.param_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.primary_output_id != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.primary_output_id);
        }
        if !self.execution_platform.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.execution_platform);
        }
        if !self.template_content.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.template_content);
        }
        for value in &self.substitutions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.file_contents.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.file_contents);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.target_id != 0 {
            os.write_uint32(1, self.target_id)?;
        }
        for v in &self.aspect_descriptor_ids {
            os.write_uint32(2, *v)?;
        };
        if !self.action_key.is_empty() {
            os.write_string(3, &self.action_key)?;
        }
        if !self.mnemonic.is_empty() {
            os.write_string(4, &self.mnemonic)?;
        }
        if self.configuration_id != 0 {
            os.write_uint32(5, self.configuration_id)?;
        }
        for v in &self.arguments {
            os.write_string(6, &v)?;
        };
        for v in &self.environment_variables {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.input_dep_set_ids {
            os.write_uint32(8, *v)?;
        };
        for v in &self.output_ids {
            os.write_uint32(9, *v)?;
        };
        if self.discovers_inputs != false {
            os.write_bool(10, self.discovers_inputs)?;
        }
        for v in &self.execution_info {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.param_files {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if self.primary_output_id != 0 {
            os.write_uint32(13, self.primary_output_id)?;
        }
        if !self.execution_platform.is_empty() {
            os.write_string(14, &self.execution_platform)?;
        }
        if !self.template_content.is_empty() {
            os.write_string(15, &self.template_content)?;
        }
        for v in &self.substitutions {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if !self.file_contents.is_empty() {
            os.write_string(17, &self.file_contents)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Action {
        Action::new()
    }

    fn clear(&mut self) {
        self.target_id = 0;
        self.aspect_descriptor_ids.clear();
        self.action_key.clear();
        self.mnemonic.clear();
        self.configuration_id = 0;
        self.arguments.clear();
        self.environment_variables.clear();
        self.input_dep_set_ids.clear();
        self.output_ids.clear();
        self.discovers_inputs = false;
        self.execution_info.clear();
        self.param_files.clear();
        self.primary_output_id = 0;
        self.execution_platform.clear();
        self.template_content.clear();
        self.substitutions.clear();
        self.file_contents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Action {
        static instance: Action = Action {
            target_id: 0,
            aspect_descriptor_ids: ::std::vec::Vec::new(),
            action_key: ::std::string::String::new(),
            mnemonic: ::std::string::String::new(),
            configuration_id: 0,
            arguments: ::std::vec::Vec::new(),
            environment_variables: ::std::vec::Vec::new(),
            input_dep_set_ids: ::std::vec::Vec::new(),
            output_ids: ::std::vec::Vec::new(),
            discovers_inputs: false,
            execution_info: ::std::vec::Vec::new(),
            param_files: ::std::vec::Vec::new(),
            primary_output_id: 0,
            execution_platform: ::std::string::String::new(),
            template_content: ::std::string::String::new(),
            substitutions: ::std::vec::Vec::new(),
            file_contents: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Action {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Action").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.Target)
pub struct Target {
    // message fields
    // @@protoc_insertion_point(field:analysis.Target.id)
    pub id: u32,
    // @@protoc_insertion_point(field:analysis.Target.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Target.rule_class_id)
    pub rule_class_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.Target.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Target {
    fn default() -> &'a Target {
        <Target as ::protobuf::Message>::default_instance()
    }
}

impl Target {
    pub fn new() -> Target {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Target| { &m.id },
            |m: &mut Target| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &Target| { &m.label },
            |m: &mut Target| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rule_class_id",
            |m: &Target| { &m.rule_class_id },
            |m: &mut Target| { &mut m.rule_class_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Target>(
            "Target",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Target {
    const NAME: &'static str = "Target";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                24 => {
                    self.rule_class_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if self.rule_class_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.rule_class_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if self.rule_class_id != 0 {
            os.write_uint32(3, self.rule_class_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Target {
        Target::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.label.clear();
        self.rule_class_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Target {
        static instance: Target = Target {
            id: 0,
            label: ::std::string::String::new(),
            rule_class_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Target {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Target").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Target {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Target {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.RuleClass)
pub struct RuleClass {
    // message fields
    // @@protoc_insertion_point(field:analysis.RuleClass.id)
    pub id: u32,
    // @@protoc_insertion_point(field:analysis.RuleClass.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.RuleClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuleClass {
    fn default() -> &'a RuleClass {
        <RuleClass as ::protobuf::Message>::default_instance()
    }
}

impl RuleClass {
    pub fn new() -> RuleClass {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RuleClass| { &m.id },
            |m: &mut RuleClass| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &RuleClass| { &m.name },
            |m: &mut RuleClass| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuleClass>(
            "RuleClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuleClass {
    const NAME: &'static str = "RuleClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuleClass {
        RuleClass::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuleClass {
        static instance: RuleClass = RuleClass {
            id: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuleClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuleClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuleClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.AspectDescriptor)
pub struct AspectDescriptor {
    // message fields
    // @@protoc_insertion_point(field:analysis.AspectDescriptor.id)
    pub id: u32,
    // @@protoc_insertion_point(field:analysis.AspectDescriptor.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.AspectDescriptor.parameters)
    pub parameters: ::std::vec::Vec<KeyValuePair>,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.AspectDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AspectDescriptor {
    fn default() -> &'a AspectDescriptor {
        <AspectDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl AspectDescriptor {
    pub fn new() -> AspectDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AspectDescriptor| { &m.id },
            |m: &mut AspectDescriptor| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AspectDescriptor| { &m.name },
            |m: &mut AspectDescriptor| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parameters",
            |m: &AspectDescriptor| { &m.parameters },
            |m: &mut AspectDescriptor| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AspectDescriptor>(
            "AspectDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AspectDescriptor {
    const NAME: &'static str = "AspectDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.parameters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.parameters {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AspectDescriptor {
        AspectDescriptor::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AspectDescriptor {
        static instance: AspectDescriptor = AspectDescriptor {
            id: 0,
            name: ::std::string::String::new(),
            parameters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AspectDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AspectDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AspectDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AspectDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.DepSetOfFiles)
pub struct DepSetOfFiles {
    // message fields
    // @@protoc_insertion_point(field:analysis.DepSetOfFiles.id)
    pub id: u32,
    // @@protoc_insertion_point(field:analysis.DepSetOfFiles.transitive_dep_set_ids)
    pub transitive_dep_set_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:analysis.DepSetOfFiles.direct_artifact_ids)
    pub direct_artifact_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.DepSetOfFiles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DepSetOfFiles {
    fn default() -> &'a DepSetOfFiles {
        <DepSetOfFiles as ::protobuf::Message>::default_instance()
    }
}

impl DepSetOfFiles {
    pub fn new() -> DepSetOfFiles {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DepSetOfFiles| { &m.id },
            |m: &mut DepSetOfFiles| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transitive_dep_set_ids",
            |m: &DepSetOfFiles| { &m.transitive_dep_set_ids },
            |m: &mut DepSetOfFiles| { &mut m.transitive_dep_set_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "direct_artifact_ids",
            |m: &DepSetOfFiles| { &m.direct_artifact_ids },
            |m: &mut DepSetOfFiles| { &mut m.direct_artifact_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DepSetOfFiles>(
            "DepSetOfFiles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DepSetOfFiles {
    const NAME: &'static str = "DepSetOfFiles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.transitive_dep_set_ids)?;
                },
                16 => {
                    self.transitive_dep_set_ids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.direct_artifact_ids)?;
                },
                24 => {
                    self.direct_artifact_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        for value in &self.transitive_dep_set_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.direct_artifact_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        for v in &self.transitive_dep_set_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.direct_artifact_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DepSetOfFiles {
        DepSetOfFiles::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.transitive_dep_set_ids.clear();
        self.direct_artifact_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DepSetOfFiles {
        static instance: DepSetOfFiles = DepSetOfFiles {
            id: 0,
            transitive_dep_set_ids: ::std::vec::Vec::new(),
            direct_artifact_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DepSetOfFiles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DepSetOfFiles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DepSetOfFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DepSetOfFiles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.Configuration)
pub struct Configuration {
    // message fields
    // @@protoc_insertion_point(field:analysis.Configuration.id)
    pub id: u32,
    // @@protoc_insertion_point(field:analysis.Configuration.mnemonic)
    pub mnemonic: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Configuration.platform_name)
    pub platform_name: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Configuration.checksum)
    pub checksum: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.Configuration.is_tool)
    pub is_tool: bool,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.Configuration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Configuration {
    fn default() -> &'a Configuration {
        <Configuration as ::protobuf::Message>::default_instance()
    }
}

impl Configuration {
    pub fn new() -> Configuration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Configuration| { &m.id },
            |m: &mut Configuration| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mnemonic",
            |m: &Configuration| { &m.mnemonic },
            |m: &mut Configuration| { &mut m.mnemonic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform_name",
            |m: &Configuration| { &m.platform_name },
            |m: &mut Configuration| { &mut m.platform_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checksum",
            |m: &Configuration| { &m.checksum },
            |m: &mut Configuration| { &mut m.checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_tool",
            |m: &Configuration| { &m.is_tool },
            |m: &mut Configuration| { &mut m.is_tool },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Configuration>(
            "Configuration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Configuration {
    const NAME: &'static str = "Configuration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.mnemonic = is.read_string()?;
                },
                26 => {
                    self.platform_name = is.read_string()?;
                },
                34 => {
                    self.checksum = is.read_string()?;
                },
                40 => {
                    self.is_tool = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.mnemonic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mnemonic);
        }
        if !self.platform_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.platform_name);
        }
        if !self.checksum.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.checksum);
        }
        if self.is_tool != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.mnemonic.is_empty() {
            os.write_string(2, &self.mnemonic)?;
        }
        if !self.platform_name.is_empty() {
            os.write_string(3, &self.platform_name)?;
        }
        if !self.checksum.is_empty() {
            os.write_string(4, &self.checksum)?;
        }
        if self.is_tool != false {
            os.write_bool(5, self.is_tool)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Configuration {
        Configuration::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.mnemonic.clear();
        self.platform_name.clear();
        self.checksum.clear();
        self.is_tool = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Configuration {
        static instance: Configuration = Configuration {
            id: 0,
            mnemonic: ::std::string::String::new(),
            platform_name: ::std::string::String::new(),
            checksum: ::std::string::String::new(),
            is_tool: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Configuration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Configuration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Configuration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.KeyValuePair)
pub struct KeyValuePair {
    // message fields
    // @@protoc_insertion_point(field:analysis.KeyValuePair.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.KeyValuePair.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.KeyValuePair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyValuePair {
    fn default() -> &'a KeyValuePair {
        <KeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePair {
    pub fn new() -> KeyValuePair {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KeyValuePair| { &m.key },
            |m: &mut KeyValuePair| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &KeyValuePair| { &m.value },
            |m: &mut KeyValuePair| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValuePair>(
            "KeyValuePair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyValuePair {
    const NAME: &'static str = "KeyValuePair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyValuePair {
        KeyValuePair::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyValuePair {
        static instance: KeyValuePair = KeyValuePair {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyValuePair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyValuePair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.ConfiguredTarget)
pub struct ConfiguredTarget {
    // message fields
    // @@protoc_insertion_point(field:analysis.ConfiguredTarget.target)
    pub target: ::protobuf::MessageField<super::build::Target>,
    // @@protoc_insertion_point(field:analysis.ConfiguredTarget.configuration)
    pub configuration: ::protobuf::MessageField<Configuration>,
    // @@protoc_insertion_point(field:analysis.ConfiguredTarget.configuration_id)
    pub configuration_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.ConfiguredTarget.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfiguredTarget {
    fn default() -> &'a ConfiguredTarget {
        <ConfiguredTarget as ::protobuf::Message>::default_instance()
    }
}

impl ConfiguredTarget {
    pub fn new() -> ConfiguredTarget {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::build::Target>(
            "target",
            |m: &ConfiguredTarget| { &m.target },
            |m: &mut ConfiguredTarget| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Configuration>(
            "configuration",
            |m: &ConfiguredTarget| { &m.configuration },
            |m: &mut ConfiguredTarget| { &mut m.configuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "configuration_id",
            |m: &ConfiguredTarget| { &m.configuration_id },
            |m: &mut ConfiguredTarget| { &mut m.configuration_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfiguredTarget>(
            "ConfiguredTarget",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfiguredTarget {
    const NAME: &'static str = "ConfiguredTarget";

    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configuration)?;
                },
                24 => {
                    self.configuration_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.configuration_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.configuration_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.configuration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.configuration_id != 0 {
            os.write_uint32(3, self.configuration_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfiguredTarget {
        ConfiguredTarget::new()
    }

    fn clear(&mut self) {
        self.target.clear();
        self.configuration.clear();
        self.configuration_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfiguredTarget {
        static instance: ConfiguredTarget = ConfiguredTarget {
            target: ::protobuf::MessageField::none(),
            configuration: ::protobuf::MessageField::none(),
            configuration_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfiguredTarget {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfiguredTarget").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfiguredTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfiguredTarget {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.CqueryResult)
pub struct CqueryResult {
    // message fields
    // @@protoc_insertion_point(field:analysis.CqueryResult.results)
    pub results: ::std::vec::Vec<ConfiguredTarget>,
    // @@protoc_insertion_point(field:analysis.CqueryResult.configurations)
    pub configurations: ::std::vec::Vec<Configuration>,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.CqueryResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CqueryResult {
    fn default() -> &'a CqueryResult {
        <CqueryResult as ::protobuf::Message>::default_instance()
    }
}

impl CqueryResult {
    pub fn new() -> CqueryResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CqueryResult| { &m.results },
            |m: &mut CqueryResult| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "configurations",
            |m: &CqueryResult| { &m.configurations },
            |m: &mut CqueryResult| { &mut m.configurations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CqueryResult>(
            "CqueryResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CqueryResult {
    const NAME: &'static str = "CqueryResult";

    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configurations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    self.configurations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.configurations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.configurations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CqueryResult {
        CqueryResult::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.configurations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CqueryResult {
        static instance: CqueryResult = CqueryResult {
            results: ::std::vec::Vec::new(),
            configurations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CqueryResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CqueryResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CqueryResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CqueryResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.ParamFile)
pub struct ParamFile {
    // message fields
    // @@protoc_insertion_point(field:analysis.ParamFile.exec_path)
    pub exec_path: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.ParamFile.arguments)
    pub arguments: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.ParamFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParamFile {
    fn default() -> &'a ParamFile {
        <ParamFile as ::protobuf::Message>::default_instance()
    }
}

impl ParamFile {
    pub fn new() -> ParamFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_path",
            |m: &ParamFile| { &m.exec_path },
            |m: &mut ParamFile| { &mut m.exec_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &ParamFile| { &m.arguments },
            |m: &mut ParamFile| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParamFile>(
            "ParamFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParamFile {
    const NAME: &'static str = "ParamFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.exec_path = is.read_string()?;
                },
                18 => {
                    self.arguments.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.exec_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.exec_path);
        }
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.exec_path.is_empty() {
            os.write_string(1, &self.exec_path)?;
        }
        for v in &self.arguments {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParamFile {
        ParamFile::new()
    }

    fn clear(&mut self) {
        self.exec_path.clear();
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParamFile {
        static instance: ParamFile = ParamFile {
            exec_path: ::std::string::String::new(),
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParamFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParamFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParamFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:analysis.PathFragment)
pub struct PathFragment {
    // message fields
    // @@protoc_insertion_point(field:analysis.PathFragment.id)
    pub id: u32,
    // @@protoc_insertion_point(field:analysis.PathFragment.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:analysis.PathFragment.parent_id)
    pub parent_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:analysis.PathFragment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PathFragment {
    fn default() -> &'a PathFragment {
        <PathFragment as ::protobuf::Message>::default_instance()
    }
}

impl PathFragment {
    pub fn new() -> PathFragment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PathFragment| { &m.id },
            |m: &mut PathFragment| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &PathFragment| { &m.label },
            |m: &mut PathFragment| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_id",
            |m: &PathFragment| { &m.parent_id },
            |m: &mut PathFragment| { &mut m.parent_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PathFragment>(
            "PathFragment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PathFragment {
    const NAME: &'static str = "PathFragment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                24 => {
                    self.parent_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if self.parent_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.parent_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if self.parent_id != 0 {
            os.write_uint32(3, self.parent_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PathFragment {
        PathFragment::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.label.clear();
        self.parent_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PathFragment {
        static instance: PathFragment = PathFragment {
            id: 0,
            label: ::std::string::String::new(),
            parent_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PathFragment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PathFragment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PathFragment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathFragment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#src/main/protobuf/analysis_v2.proto\x12\x08analysis\x1a\x1dsrc/main/p\
    rotobuf/build.proto\"\xe3\x03\n\x14ActionGraphContainer\x120\n\tartifact\
    s\x18\x01\x20\x03(\x0b2\x12.analysis.ArtifactR\tartifacts\x12*\n\x07acti\
    ons\x18\x02\x20\x03(\x0b2\x10.analysis.ActionR\x07actions\x12*\n\x07targ\
    ets\x18\x03\x20\x03(\x0b2\x10.analysis.TargetR\x07targets\x12@\n\x10dep_\
    set_of_files\x18\x04\x20\x03(\x0b2\x17.analysis.DepSetOfFilesR\rdepSetOf\
    Files\x12=\n\rconfiguration\x18\x05\x20\x03(\x0b2\x17.analysis.Configura\
    tionR\rconfiguration\x12I\n\x12aspect_descriptors\x18\x06\x20\x03(\x0b2\
    \x1a.analysis.AspectDescriptorR\x11aspectDescriptors\x126\n\x0crule_clas\
    ses\x18\x07\x20\x03(\x0b2\x13.analysis.RuleClassR\x0bruleClasses\x12=\n\
    \x0epath_fragments\x18\x08\x20\x03(\x0b2\x16.analysis.PathFragmentR\rpat\
    hFragments\"n\n\x08Artifact\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\
    \x12(\n\x10path_fragment_id\x18\x02\x20\x01(\rR\x0epathFragmentId\x12(\n\
    \x10is_tree_artifact\x18\x03\x20\x01(\x08R\x0eisTreeArtifact\"\xfd\x05\n\
    \x06Action\x12\x1b\n\ttarget_id\x18\x01\x20\x01(\rR\x08targetId\x122\n\
    \x15aspect_descriptor_ids\x18\x02\x20\x03(\rR\x13aspectDescriptorIds\x12\
    \x1d\n\naction_key\x18\x03\x20\x01(\tR\tactionKey\x12\x1a\n\x08mnemonic\
    \x18\x04\x20\x01(\tR\x08mnemonic\x12)\n\x10configuration_id\x18\x05\x20\
    \x01(\rR\x0fconfigurationId\x12\x1c\n\targuments\x18\x06\x20\x03(\tR\tar\
    guments\x12K\n\x15environment_variables\x18\x07\x20\x03(\x0b2\x16.analys\
    is.KeyValuePairR\x14environmentVariables\x12)\n\x11input_dep_set_ids\x18\
    \x08\x20\x03(\rR\x0einputDepSetIds\x12\x1d\n\noutput_ids\x18\t\x20\x03(\
    \rR\toutputIds\x12)\n\x10discovers_inputs\x18\n\x20\x01(\x08R\x0fdiscove\
    rsInputs\x12=\n\x0eexecution_info\x18\x0b\x20\x03(\x0b2\x16.analysis.Key\
    ValuePairR\rexecutionInfo\x124\n\x0bparam_files\x18\x0c\x20\x03(\x0b2\
    \x13.analysis.ParamFileR\nparamFiles\x12*\n\x11primary_output_id\x18\r\
    \x20\x01(\rR\x0fprimaryOutputId\x12-\n\x12execution_platform\x18\x0e\x20\
    \x01(\tR\x11executionPlatform\x12)\n\x10template_content\x18\x0f\x20\x01\
    (\tR\x0ftemplateContent\x12<\n\rsubstitutions\x18\x10\x20\x03(\x0b2\x16.\
    analysis.KeyValuePairR\rsubstitutions\x12#\n\rfile_contents\x18\x11\x20\
    \x01(\tR\x0cfileContents\"R\n\x06Target\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \rR\x02id\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12\"\n\rrule_\
    class_id\x18\x03\x20\x01(\rR\x0bruleClassId\"/\n\tRuleClass\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\"n\n\x10AspectDescriptor\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x126\n\nparameters\
    \x18\x03\x20\x03(\x0b2\x16.analysis.KeyValuePairR\nparameters\"\x84\x01\
    \n\rDepSetOfFiles\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x123\n\x16tr\
    ansitive_dep_set_ids\x18\x02\x20\x03(\rR\x13transitiveDepSetIds\x12.\n\
    \x13direct_artifact_ids\x18\x03\x20\x03(\rR\x11directArtifactIds\"\x95\
    \x01\n\rConfiguration\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x1a\
    \n\x08mnemonic\x18\x02\x20\x01(\tR\x08mnemonic\x12#\n\rplatform_name\x18\
    \x03\x20\x01(\tR\x0cplatformName\x12\x1a\n\x08checksum\x18\x04\x20\x01(\
    \tR\x08checksum\x12\x17\n\x07is_tool\x18\x05\x20\x01(\x08R\x06isTool\"6\
    \n\x0cKeyValuePair\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value\"\xad\x01\n\x10ConfiguredTarget\
    \x12+\n\x06target\x18\x01\x20\x01(\x0b2\x13.blaze_query.TargetR\x06targe\
    t\x12A\n\rconfiguration\x18\x02\x20\x01(\x0b2\x17.analysis.Configuration\
    R\rconfigurationB\x02\x18\x01\x12)\n\x10configuration_id\x18\x03\x20\x01\
    (\rR\x0fconfigurationId\"\x85\x01\n\x0cCqueryResult\x124\n\x07results\
    \x18\x01\x20\x03(\x0b2\x1a.analysis.ConfiguredTargetR\x07results\x12?\n\
    \x0econfigurations\x18\x02\x20\x03(\x0b2\x17.analysis.ConfigurationR\x0e\
    configurations\"F\n\tParamFile\x12\x1b\n\texec_path\x18\x01\x20\x01(\tR\
    \x08execPath\x12\x1c\n\targuments\x18\x02\x20\x03(\tR\targuments\"Q\n\
    \x0cPathFragment\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x14\n\x05\
    label\x18\x02\x20\x01(\tR\x05label\x12\x1b\n\tparent_id\x18\x03\x20\x01(\
    \rR\x08parentIdB:\n&com.google.devtools.build.lib.analysisB\x10AnalysisP\
    rotosV2b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::build::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(13);
            messages.push(ActionGraphContainer::generated_message_descriptor_data());
            messages.push(Artifact::generated_message_descriptor_data());
            messages.push(Action::generated_message_descriptor_data());
            messages.push(Target::generated_message_descriptor_data());
            messages.push(RuleClass::generated_message_descriptor_data());
            messages.push(AspectDescriptor::generated_message_descriptor_data());
            messages.push(DepSetOfFiles::generated_message_descriptor_data());
            messages.push(Configuration::generated_message_descriptor_data());
            messages.push(KeyValuePair::generated_message_descriptor_data());
            messages.push(ConfiguredTarget::generated_message_descriptor_data());
            messages.push(CqueryResult::generated_message_descriptor_data());
            messages.push(ParamFile::generated_message_descriptor_data());
            messages.push(PathFragment::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
