// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/main/protobuf/build.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.License)
pub struct License {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.License.license_type)
    pub license_type: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.License.exception)
    pub exception: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.License.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a License {
    fn default() -> &'a License {
        <License as ::protobuf::Message>::default_instance()
    }
}

impl License {
    pub fn new() -> License {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "license_type",
            |m: &License| { &m.license_type },
            |m: &mut License| { &mut m.license_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exception",
            |m: &License| { &m.exception },
            |m: &mut License| { &mut m.exception },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<License>(
            "License",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for License {
    const NAME: &'static str = "License";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.license_type.push(is.read_string()?);
                },
                18 => {
                    self.exception.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.license_type {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.exception {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.license_type {
            os.write_string(1, &v)?;
        };
        for v in &self.exception {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> License {
        License::new()
    }

    fn clear(&mut self) {
        self.license_type.clear();
        self.exception.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static License {
        static instance: License = License {
            license_type: ::std::vec::Vec::new(),
            exception: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for License {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("License").unwrap()).clone()
    }
}

impl ::std::fmt::Display for License {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for License {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.StringDictEntry)
pub struct StringDictEntry {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.StringDictEntry.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.StringDictEntry.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.StringDictEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringDictEntry {
    fn default() -> &'a StringDictEntry {
        <StringDictEntry as ::protobuf::Message>::default_instance()
    }
}

impl StringDictEntry {
    pub fn new() -> StringDictEntry {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &StringDictEntry| { &m.key },
            |m: &mut StringDictEntry| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &StringDictEntry| { &m.value },
            |m: &mut StringDictEntry| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringDictEntry>(
            "StringDictEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringDictEntry {
    const NAME: &'static str = "StringDictEntry";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringDictEntry {
        StringDictEntry::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringDictEntry {
        static instance: StringDictEntry = StringDictEntry {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringDictEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringDictEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringDictEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringDictEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.LabelDictUnaryEntry)
pub struct LabelDictUnaryEntry {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.LabelDictUnaryEntry.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.LabelDictUnaryEntry.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.LabelDictUnaryEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelDictUnaryEntry {
    fn default() -> &'a LabelDictUnaryEntry {
        <LabelDictUnaryEntry as ::protobuf::Message>::default_instance()
    }
}

impl LabelDictUnaryEntry {
    pub fn new() -> LabelDictUnaryEntry {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &LabelDictUnaryEntry| { &m.key },
            |m: &mut LabelDictUnaryEntry| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &LabelDictUnaryEntry| { &m.value },
            |m: &mut LabelDictUnaryEntry| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelDictUnaryEntry>(
            "LabelDictUnaryEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelDictUnaryEntry {
    const NAME: &'static str = "LabelDictUnaryEntry";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelDictUnaryEntry {
        LabelDictUnaryEntry::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelDictUnaryEntry {
        static instance: LabelDictUnaryEntry = LabelDictUnaryEntry {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelDictUnaryEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelDictUnaryEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelDictUnaryEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelDictUnaryEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.LabelListDictEntry)
pub struct LabelListDictEntry {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.LabelListDictEntry.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.LabelListDictEntry.value)
    pub value: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.LabelListDictEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelListDictEntry {
    fn default() -> &'a LabelListDictEntry {
        <LabelListDictEntry as ::protobuf::Message>::default_instance()
    }
}

impl LabelListDictEntry {
    pub fn new() -> LabelListDictEntry {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &LabelListDictEntry| { &m.key },
            |m: &mut LabelListDictEntry| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "value",
            |m: &LabelListDictEntry| { &m.value },
            |m: &mut LabelListDictEntry| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelListDictEntry>(
            "LabelListDictEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelListDictEntry {
    const NAME: &'static str = "LabelListDictEntry";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.value {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.value {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelListDictEntry {
        LabelListDictEntry::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelListDictEntry {
        static instance: LabelListDictEntry = LabelListDictEntry {
            key: ::std::option::Option::None,
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelListDictEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelListDictEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelListDictEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelListDictEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.LabelKeyedStringDictEntry)
pub struct LabelKeyedStringDictEntry {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.LabelKeyedStringDictEntry.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.LabelKeyedStringDictEntry.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.LabelKeyedStringDictEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelKeyedStringDictEntry {
    fn default() -> &'a LabelKeyedStringDictEntry {
        <LabelKeyedStringDictEntry as ::protobuf::Message>::default_instance()
    }
}

impl LabelKeyedStringDictEntry {
    pub fn new() -> LabelKeyedStringDictEntry {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &LabelKeyedStringDictEntry| { &m.key },
            |m: &mut LabelKeyedStringDictEntry| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &LabelKeyedStringDictEntry| { &m.value },
            |m: &mut LabelKeyedStringDictEntry| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelKeyedStringDictEntry>(
            "LabelKeyedStringDictEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelKeyedStringDictEntry {
    const NAME: &'static str = "LabelKeyedStringDictEntry";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelKeyedStringDictEntry {
        LabelKeyedStringDictEntry::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelKeyedStringDictEntry {
        static instance: LabelKeyedStringDictEntry = LabelKeyedStringDictEntry {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelKeyedStringDictEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelKeyedStringDictEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelKeyedStringDictEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelKeyedStringDictEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.StringListDictEntry)
pub struct StringListDictEntry {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.StringListDictEntry.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.StringListDictEntry.value)
    pub value: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.StringListDictEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringListDictEntry {
    fn default() -> &'a StringListDictEntry {
        <StringListDictEntry as ::protobuf::Message>::default_instance()
    }
}

impl StringListDictEntry {
    pub fn new() -> StringListDictEntry {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &StringListDictEntry| { &m.key },
            |m: &mut StringListDictEntry| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "value",
            |m: &StringListDictEntry| { &m.value },
            |m: &mut StringListDictEntry| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringListDictEntry>(
            "StringListDictEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringListDictEntry {
    const NAME: &'static str = "StringListDictEntry";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.value {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.value {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringListDictEntry {
        StringListDictEntry::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringListDictEntry {
        static instance: StringListDictEntry = StringListDictEntry {
            key: ::std::option::Option::None,
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringListDictEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringListDictEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringListDictEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringListDictEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.FilesetEntry)
pub struct FilesetEntry {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.FilesetEntry.source)
    pub source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.FilesetEntry.destination_directory)
    pub destination_directory: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.FilesetEntry.files_present)
    pub files_present: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.FilesetEntry.file)
    pub file: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.FilesetEntry.exclude)
    pub exclude: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.FilesetEntry.symlink_behavior)
    pub symlink_behavior: ::std::option::Option<::protobuf::EnumOrUnknown<fileset_entry::SymlinkBehavior>>,
    // @@protoc_insertion_point(field:blaze_query.FilesetEntry.strip_prefix)
    pub strip_prefix: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.FilesetEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FilesetEntry {
    fn default() -> &'a FilesetEntry {
        <FilesetEntry as ::protobuf::Message>::default_instance()
    }
}

impl FilesetEntry {
    pub fn new() -> FilesetEntry {
        ::std::default::Default::default()
    }

    // required string source = 1;

    pub fn source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string destination_directory = 2;

    pub fn destination_directory(&self) -> &str {
        match self.destination_directory.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_destination_directory(&mut self) {
        self.destination_directory = ::std::option::Option::None;
    }

    pub fn has_destination_directory(&self) -> bool {
        self.destination_directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination_directory(&mut self, v: ::std::string::String) {
        self.destination_directory = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_directory(&mut self) -> &mut ::std::string::String {
        if self.destination_directory.is_none() {
            self.destination_directory = ::std::option::Option::Some(::std::string::String::new());
        }
        self.destination_directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination_directory(&mut self) -> ::std::string::String {
        self.destination_directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool files_present = 7;

    pub fn files_present(&self) -> bool {
        self.files_present.unwrap_or(false)
    }

    pub fn clear_files_present(&mut self) {
        self.files_present = ::std::option::Option::None;
    }

    pub fn has_files_present(&self) -> bool {
        self.files_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_present(&mut self, v: bool) {
        self.files_present = ::std::option::Option::Some(v);
    }

    // optional .blaze_query.FilesetEntry.SymlinkBehavior symlink_behavior = 5;

    pub fn symlink_behavior(&self) -> fileset_entry::SymlinkBehavior {
        match self.symlink_behavior {
            Some(e) => e.enum_value_or(fileset_entry::SymlinkBehavior::COPY),
            None => fileset_entry::SymlinkBehavior::COPY,
        }
    }

    pub fn clear_symlink_behavior(&mut self) {
        self.symlink_behavior = ::std::option::Option::None;
    }

    pub fn has_symlink_behavior(&self) -> bool {
        self.symlink_behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symlink_behavior(&mut self, v: fileset_entry::SymlinkBehavior) {
        self.symlink_behavior = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string strip_prefix = 6;

    pub fn strip_prefix(&self) -> &str {
        match self.strip_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_strip_prefix(&mut self) {
        self.strip_prefix = ::std::option::Option::None;
    }

    pub fn has_strip_prefix(&self) -> bool {
        self.strip_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_prefix(&mut self, v: ::std::string::String) {
        self.strip_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strip_prefix(&mut self) -> &mut ::std::string::String {
        if self.strip_prefix.is_none() {
            self.strip_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.strip_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_strip_prefix(&mut self) -> ::std::string::String {
        self.strip_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &FilesetEntry| { &m.source },
            |m: &mut FilesetEntry| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "destination_directory",
            |m: &FilesetEntry| { &m.destination_directory },
            |m: &mut FilesetEntry| { &mut m.destination_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "files_present",
            |m: &FilesetEntry| { &m.files_present },
            |m: &mut FilesetEntry| { &mut m.files_present },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &FilesetEntry| { &m.file },
            |m: &mut FilesetEntry| { &mut m.file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exclude",
            |m: &FilesetEntry| { &m.exclude },
            |m: &mut FilesetEntry| { &mut m.exclude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symlink_behavior",
            |m: &FilesetEntry| { &m.symlink_behavior },
            |m: &mut FilesetEntry| { &mut m.symlink_behavior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strip_prefix",
            |m: &FilesetEntry| { &m.strip_prefix },
            |m: &mut FilesetEntry| { &mut m.strip_prefix },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FilesetEntry>(
            "FilesetEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FilesetEntry {
    const NAME: &'static str = "FilesetEntry";

    fn is_initialized(&self) -> bool {
        if self.source.is_none() {
            return false;
        }
        if self.destination_directory.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.destination_directory = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.files_present = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.file.push(is.read_string()?);
                },
                34 => {
                    self.exclude.push(is.read_string()?);
                },
                40 => {
                    self.symlink_behavior = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.strip_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.destination_directory.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.files_present {
            my_size += 1 + 1;
        }
        for value in &self.file {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.exclude {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.symlink_behavior {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.strip_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.destination_directory.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.files_present {
            os.write_bool(7, v)?;
        }
        for v in &self.file {
            os.write_string(3, &v)?;
        };
        for v in &self.exclude {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.symlink_behavior {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.strip_prefix.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FilesetEntry {
        FilesetEntry::new()
    }

    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.destination_directory = ::std::option::Option::None;
        self.files_present = ::std::option::Option::None;
        self.file.clear();
        self.exclude.clear();
        self.symlink_behavior = ::std::option::Option::None;
        self.strip_prefix = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FilesetEntry {
        static instance: FilesetEntry = FilesetEntry {
            source: ::std::option::Option::None,
            destination_directory: ::std::option::Option::None,
            files_present: ::std::option::Option::None,
            file: ::std::vec::Vec::new(),
            exclude: ::std::vec::Vec::new(),
            symlink_behavior: ::std::option::Option::None,
            strip_prefix: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FilesetEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FilesetEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FilesetEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilesetEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FilesetEntry`
pub mod fileset_entry {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:blaze_query.FilesetEntry.SymlinkBehavior)
    pub enum SymlinkBehavior {
        // @@protoc_insertion_point(enum_value:blaze_query.FilesetEntry.SymlinkBehavior.COPY)
        COPY = 1,
        // @@protoc_insertion_point(enum_value:blaze_query.FilesetEntry.SymlinkBehavior.DEREFERENCE)
        DEREFERENCE = 2,
    }

    impl ::protobuf::Enum for SymlinkBehavior {
        const NAME: &'static str = "SymlinkBehavior";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SymlinkBehavior> {
            match value {
                1 => ::std::option::Option::Some(SymlinkBehavior::COPY),
                2 => ::std::option::Option::Some(SymlinkBehavior::DEREFERENCE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SymlinkBehavior] = &[
            SymlinkBehavior::COPY,
            SymlinkBehavior::DEREFERENCE,
        ];
    }

    impl ::protobuf::EnumFull for SymlinkBehavior {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FilesetEntry.SymlinkBehavior").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                SymlinkBehavior::COPY => 0,
                SymlinkBehavior::DEREFERENCE => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for SymlinkBehavior {
        fn default() -> Self {
            SymlinkBehavior::COPY
        }
    }

    impl SymlinkBehavior {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SymlinkBehavior>("FilesetEntry.SymlinkBehavior")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.Attribute)
pub struct Attribute {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.Attribute.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.explicitly_specified)
    pub explicitly_specified: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.nodep)
    pub nodep: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<attribute::Discriminator>>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.int_value)
    pub int_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.boolean_value)
    pub boolean_value: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.tristate_value)
    pub tristate_value: ::std::option::Option<::protobuf::EnumOrUnknown<attribute::Tristate>>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.string_list_value)
    pub string_list_value: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.license)
    pub license: ::protobuf::MessageField<License>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.string_dict_value)
    pub string_dict_value: ::std::vec::Vec<StringDictEntry>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.fileset_list_value)
    pub fileset_list_value: ::std::vec::Vec<FilesetEntry>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.label_list_dict_value)
    pub label_list_dict_value: ::std::vec::Vec<LabelListDictEntry>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.string_list_dict_value)
    pub string_list_dict_value: ::std::vec::Vec<StringListDictEntry>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.int_list_value)
    pub int_list_value: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.label_dict_unary_value)
    pub label_dict_unary_value: ::std::vec::Vec<LabelDictUnaryEntry>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.label_keyed_string_dict_value)
    pub label_keyed_string_dict_value: ::std::vec::Vec<LabelKeyedStringDictEntry>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.selector_list)
    pub selector_list: ::protobuf::MessageField<attribute::SelectorList>,
    // @@protoc_insertion_point(field:blaze_query.Attribute.DEPRECATED_string_dict_unary_value)
    pub DEPRECATED_string_dict_unary_value: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.Attribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Attribute {
    fn default() -> &'a Attribute {
        <Attribute as ::protobuf::Message>::default_instance()
    }
}

impl Attribute {
    pub fn new() -> Attribute {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool explicitly_specified = 13;

    pub fn explicitly_specified(&self) -> bool {
        self.explicitly_specified.unwrap_or(false)
    }

    pub fn clear_explicitly_specified(&mut self) {
        self.explicitly_specified = ::std::option::Option::None;
    }

    pub fn has_explicitly_specified(&self) -> bool {
        self.explicitly_specified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicitly_specified(&mut self, v: bool) {
        self.explicitly_specified = ::std::option::Option::Some(v);
    }

    // optional bool nodep = 20;

    pub fn nodep(&self) -> bool {
        self.nodep.unwrap_or(false)
    }

    pub fn clear_nodep(&mut self) {
        self.nodep = ::std::option::Option::None;
    }

    pub fn has_nodep(&self) -> bool {
        self.nodep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodep(&mut self, v: bool) {
        self.nodep = ::std::option::Option::Some(v);
    }

    // required .blaze_query.Attribute.Discriminator type = 2;

    pub fn type_(&self) -> attribute::Discriminator {
        match self.type_ {
            Some(e) => e.enum_value_or(attribute::Discriminator::INTEGER),
            None => attribute::Discriminator::INTEGER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: attribute::Discriminator) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 int_value = 3;

    pub fn int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool boolean_value = 14;

    pub fn boolean_value(&self) -> bool {
        self.boolean_value.unwrap_or(false)
    }

    pub fn clear_boolean_value(&mut self) {
        self.boolean_value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        self.boolean_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.boolean_value = ::std::option::Option::Some(v);
    }

    // optional .blaze_query.Attribute.Tristate tristate_value = 15;

    pub fn tristate_value(&self) -> attribute::Tristate {
        match self.tristate_value {
            Some(e) => e.enum_value_or(attribute::Tristate::NO),
            None => attribute::Tristate::NO,
        }
    }

    pub fn clear_tristate_value(&mut self) {
        self.tristate_value = ::std::option::Option::None;
    }

    pub fn has_tristate_value(&self) -> bool {
        self.tristate_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tristate_value(&mut self, v: attribute::Tristate) {
        self.tristate_value = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Attribute| { &m.name },
            |m: &mut Attribute| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explicitly_specified",
            |m: &Attribute| { &m.explicitly_specified },
            |m: &mut Attribute| { &mut m.explicitly_specified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodep",
            |m: &Attribute| { &m.nodep },
            |m: &mut Attribute| { &mut m.nodep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Attribute| { &m.type_ },
            |m: &mut Attribute| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_value",
            |m: &Attribute| { &m.int_value },
            |m: &mut Attribute| { &mut m.int_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &Attribute| { &m.string_value },
            |m: &mut Attribute| { &mut m.string_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "boolean_value",
            |m: &Attribute| { &m.boolean_value },
            |m: &mut Attribute| { &mut m.boolean_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tristate_value",
            |m: &Attribute| { &m.tristate_value },
            |m: &mut Attribute| { &mut m.tristate_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_list_value",
            |m: &Attribute| { &m.string_list_value },
            |m: &mut Attribute| { &mut m.string_list_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, License>(
            "license",
            |m: &Attribute| { &m.license },
            |m: &mut Attribute| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_dict_value",
            |m: &Attribute| { &m.string_dict_value },
            |m: &mut Attribute| { &mut m.string_dict_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fileset_list_value",
            |m: &Attribute| { &m.fileset_list_value },
            |m: &mut Attribute| { &mut m.fileset_list_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_list_dict_value",
            |m: &Attribute| { &m.label_list_dict_value },
            |m: &mut Attribute| { &mut m.label_list_dict_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_list_dict_value",
            |m: &Attribute| { &m.string_list_dict_value },
            |m: &mut Attribute| { &mut m.string_list_dict_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "int_list_value",
            |m: &Attribute| { &m.int_list_value },
            |m: &mut Attribute| { &mut m.int_list_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_dict_unary_value",
            |m: &Attribute| { &m.label_dict_unary_value },
            |m: &mut Attribute| { &mut m.label_dict_unary_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_keyed_string_dict_value",
            |m: &Attribute| { &m.label_keyed_string_dict_value },
            |m: &mut Attribute| { &mut m.label_keyed_string_dict_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, attribute::SelectorList>(
            "selector_list",
            |m: &Attribute| { &m.selector_list },
            |m: &mut Attribute| { &mut m.selector_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "DEPRECATED_string_dict_unary_value",
            |m: &Attribute| { &m.DEPRECATED_string_dict_unary_value },
            |m: &mut Attribute| { &mut m.DEPRECATED_string_dict_unary_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Attribute>(
            "Attribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Attribute {
    const NAME: &'static str = "Attribute";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.type_.is_none() {
            return false;
        }
        for v in &self.license {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.string_dict_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fileset_list_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_list_dict_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.string_list_dict_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_dict_unary_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_keyed_string_dict_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selector_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.explicitly_specified = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.nodep = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.int_value = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.boolean_value = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.tristate_value = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.string_list_value.push(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.license)?;
                },
                66 => {
                    self.string_dict_value.push(is.read_message()?);
                },
                74 => {
                    self.fileset_list_value.push(is.read_message()?);
                },
                82 => {
                    self.label_list_dict_value.push(is.read_message()?);
                },
                90 => {
                    self.string_list_dict_value.push(is.read_message()?);
                },
                138 => {
                    is.read_repeated_packed_int32_into(&mut self.int_list_value)?;
                },
                136 => {
                    self.int_list_value.push(is.read_int32()?);
                },
                154 => {
                    self.label_dict_unary_value.push(is.read_message()?);
                },
                178 => {
                    self.label_keyed_string_dict_value.push(is.read_message()?);
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector_list)?;
                },
                146 => {
                    self.DEPRECATED_string_dict_unary_value.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.explicitly_specified {
            my_size += 1 + 1;
        }
        if let Some(v) = self.nodep {
            my_size += 2 + 1;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.int_value {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.boolean_value {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tristate_value {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        for value in &self.string_list_value {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.license.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.string_dict_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fileset_list_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.label_list_dict_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.string_list_dict_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.int_list_value {
            my_size += ::protobuf::rt::int32_size(17, *value);
        };
        for value in &self.label_dict_unary_value {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.label_keyed_string_dict_value {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.selector_list.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.DEPRECATED_string_dict_unary_value {
            my_size += ::protobuf::rt::bytes_size(18, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.explicitly_specified {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.nodep {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.boolean_value {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.tristate_value {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.string_list_value {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.license.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.string_dict_value {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.fileset_list_value {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.label_list_dict_value {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.string_list_dict_value {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.int_list_value {
            os.write_int32(17, *v)?;
        };
        for v in &self.label_dict_unary_value {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        for v in &self.label_keyed_string_dict_value {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.selector_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        for v in &self.DEPRECATED_string_dict_unary_value {
            os.write_bytes(18, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Attribute {
        Attribute::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.explicitly_specified = ::std::option::Option::None;
        self.nodep = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.boolean_value = ::std::option::Option::None;
        self.tristate_value = ::std::option::Option::None;
        self.string_list_value.clear();
        self.license.clear();
        self.string_dict_value.clear();
        self.fileset_list_value.clear();
        self.label_list_dict_value.clear();
        self.string_list_dict_value.clear();
        self.int_list_value.clear();
        self.label_dict_unary_value.clear();
        self.label_keyed_string_dict_value.clear();
        self.selector_list.clear();
        self.DEPRECATED_string_dict_unary_value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Attribute {
        static instance: Attribute = Attribute {
            name: ::std::option::Option::None,
            explicitly_specified: ::std::option::Option::None,
            nodep: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            boolean_value: ::std::option::Option::None,
            tristate_value: ::std::option::Option::None,
            string_list_value: ::std::vec::Vec::new(),
            license: ::protobuf::MessageField::none(),
            string_dict_value: ::std::vec::Vec::new(),
            fileset_list_value: ::std::vec::Vec::new(),
            label_list_dict_value: ::std::vec::Vec::new(),
            string_list_dict_value: ::std::vec::Vec::new(),
            int_list_value: ::std::vec::Vec::new(),
            label_dict_unary_value: ::std::vec::Vec::new(),
            label_keyed_string_dict_value: ::std::vec::Vec::new(),
            selector_list: ::protobuf::MessageField::none(),
            DEPRECATED_string_dict_unary_value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Attribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Attribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Attribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Attribute`
pub mod attribute {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:blaze_query.Attribute.SelectorEntry)
    pub struct SelectorEntry {
        // message fields
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.label)
        pub label: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.is_default_value)
        pub is_default_value: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.int_value)
        pub int_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.string_value)
        pub string_value: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.boolean_value)
        pub boolean_value: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.tristate_value)
        pub tristate_value: ::std::option::Option<::protobuf::EnumOrUnknown<Tristate>>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.string_list_value)
        pub string_list_value: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.license)
        pub license: ::protobuf::MessageField<super::License>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.string_dict_value)
        pub string_dict_value: ::std::vec::Vec<super::StringDictEntry>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.fileset_list_value)
        pub fileset_list_value: ::std::vec::Vec<super::FilesetEntry>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.label_list_dict_value)
        pub label_list_dict_value: ::std::vec::Vec<super::LabelListDictEntry>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.string_list_dict_value)
        pub string_list_dict_value: ::std::vec::Vec<super::StringListDictEntry>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.int_list_value)
        pub int_list_value: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.label_dict_unary_value)
        pub label_dict_unary_value: ::std::vec::Vec<super::LabelDictUnaryEntry>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.label_keyed_string_dict_value)
        pub label_keyed_string_dict_value: ::std::vec::Vec<super::LabelKeyedStringDictEntry>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorEntry.DEPRECATED_string_dict_unary_value)
        pub DEPRECATED_string_dict_unary_value: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:blaze_query.Attribute.SelectorEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SelectorEntry {
        fn default() -> &'a SelectorEntry {
            <SelectorEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl SelectorEntry {
        pub fn new() -> SelectorEntry {
            ::std::default::Default::default()
        }

        // optional string label = 1;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_default_value = 16;

        pub fn is_default_value(&self) -> bool {
            self.is_default_value.unwrap_or(false)
        }

        pub fn clear_is_default_value(&mut self) {
            self.is_default_value = ::std::option::Option::None;
        }

        pub fn has_is_default_value(&self) -> bool {
            self.is_default_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_default_value(&mut self, v: bool) {
            self.is_default_value = ::std::option::Option::Some(v);
        }

        // optional int32 int_value = 2;

        pub fn int_value(&self) -> i32 {
            self.int_value.unwrap_or(0)
        }

        pub fn clear_int_value(&mut self) {
            self.int_value = ::std::option::Option::None;
        }

        pub fn has_int_value(&self) -> bool {
            self.int_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_int_value(&mut self, v: i32) {
            self.int_value = ::std::option::Option::Some(v);
        }

        // optional string string_value = 3;

        pub fn string_value(&self) -> &str {
            match self.string_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string_value(&mut self) {
            self.string_value = ::std::option::Option::None;
        }

        pub fn has_string_value(&self) -> bool {
            self.string_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string_value(&mut self, v: ::std::string::String) {
            self.string_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
            if self.string_value.is_none() {
                self.string_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_string_value(&mut self) -> ::std::string::String {
            self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool boolean_value = 4;

        pub fn boolean_value(&self) -> bool {
            self.boolean_value.unwrap_or(false)
        }

        pub fn clear_boolean_value(&mut self) {
            self.boolean_value = ::std::option::Option::None;
        }

        pub fn has_boolean_value(&self) -> bool {
            self.boolean_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_boolean_value(&mut self, v: bool) {
            self.boolean_value = ::std::option::Option::Some(v);
        }

        // optional .blaze_query.Attribute.Tristate tristate_value = 5;

        pub fn tristate_value(&self) -> Tristate {
            match self.tristate_value {
                Some(e) => e.enum_value_or(Tristate::NO),
                None => Tristate::NO,
            }
        }

        pub fn clear_tristate_value(&mut self) {
            self.tristate_value = ::std::option::Option::None;
        }

        pub fn has_tristate_value(&self) -> bool {
            self.tristate_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tristate_value(&mut self, v: Tristate) {
            self.tristate_value = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(16);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "label",
                |m: &SelectorEntry| { &m.label },
                |m: &mut SelectorEntry| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_default_value",
                |m: &SelectorEntry| { &m.is_default_value },
                |m: &mut SelectorEntry| { &mut m.is_default_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "int_value",
                |m: &SelectorEntry| { &m.int_value },
                |m: &mut SelectorEntry| { &mut m.int_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "string_value",
                |m: &SelectorEntry| { &m.string_value },
                |m: &mut SelectorEntry| { &mut m.string_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "boolean_value",
                |m: &SelectorEntry| { &m.boolean_value },
                |m: &mut SelectorEntry| { &mut m.boolean_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tristate_value",
                |m: &SelectorEntry| { &m.tristate_value },
                |m: &mut SelectorEntry| { &mut m.tristate_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "string_list_value",
                |m: &SelectorEntry| { &m.string_list_value },
                |m: &mut SelectorEntry| { &mut m.string_list_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::License>(
                "license",
                |m: &SelectorEntry| { &m.license },
                |m: &mut SelectorEntry| { &mut m.license },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "string_dict_value",
                |m: &SelectorEntry| { &m.string_dict_value },
                |m: &mut SelectorEntry| { &mut m.string_dict_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "fileset_list_value",
                |m: &SelectorEntry| { &m.fileset_list_value },
                |m: &mut SelectorEntry| { &mut m.fileset_list_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "label_list_dict_value",
                |m: &SelectorEntry| { &m.label_list_dict_value },
                |m: &mut SelectorEntry| { &mut m.label_list_dict_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "string_list_dict_value",
                |m: &SelectorEntry| { &m.string_list_dict_value },
                |m: &mut SelectorEntry| { &mut m.string_list_dict_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "int_list_value",
                |m: &SelectorEntry| { &m.int_list_value },
                |m: &mut SelectorEntry| { &mut m.int_list_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "label_dict_unary_value",
                |m: &SelectorEntry| { &m.label_dict_unary_value },
                |m: &mut SelectorEntry| { &mut m.label_dict_unary_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "label_keyed_string_dict_value",
                |m: &SelectorEntry| { &m.label_keyed_string_dict_value },
                |m: &mut SelectorEntry| { &mut m.label_keyed_string_dict_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "DEPRECATED_string_dict_unary_value",
                |m: &SelectorEntry| { &m.DEPRECATED_string_dict_unary_value },
                |m: &mut SelectorEntry| { &mut m.DEPRECATED_string_dict_unary_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectorEntry>(
                "Attribute.SelectorEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SelectorEntry {
        const NAME: &'static str = "SelectorEntry";

        fn is_initialized(&self) -> bool {
            for v in &self.license {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.string_dict_value {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.fileset_list_value {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.label_list_dict_value {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.string_list_dict_value {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.label_dict_unary_value {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.label_keyed_string_dict_value {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    128 => {
                        self.is_default_value = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.int_value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.string_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.boolean_value = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.tristate_value = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        self.string_list_value.push(is.read_string()?);
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.license)?;
                    },
                    66 => {
                        self.string_dict_value.push(is.read_message()?);
                    },
                    74 => {
                        self.fileset_list_value.push(is.read_message()?);
                    },
                    82 => {
                        self.label_list_dict_value.push(is.read_message()?);
                    },
                    90 => {
                        self.string_list_dict_value.push(is.read_message()?);
                    },
                    106 => {
                        is.read_repeated_packed_int32_into(&mut self.int_list_value)?;
                    },
                    104 => {
                        self.int_list_value.push(is.read_int32()?);
                    },
                    122 => {
                        self.label_dict_unary_value.push(is.read_message()?);
                    },
                    138 => {
                        self.label_keyed_string_dict_value.push(is.read_message()?);
                    },
                    114 => {
                        self.DEPRECATED_string_dict_unary_value.push(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.label.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.is_default_value {
                my_size += 2 + 1;
            }
            if let Some(v) = self.int_value {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.string_value.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.boolean_value {
                my_size += 1 + 1;
            }
            if let Some(v) = self.tristate_value {
                my_size += ::protobuf::rt::int32_size(5, v.value());
            }
            for value in &self.string_list_value {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            if let Some(v) = self.license.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.string_dict_value {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.fileset_list_value {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.label_list_dict_value {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.string_list_dict_value {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.int_list_value {
                my_size += ::protobuf::rt::int32_size(13, *value);
            };
            for value in &self.label_dict_unary_value {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.label_keyed_string_dict_value {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.DEPRECATED_string_dict_unary_value {
                my_size += ::protobuf::rt::bytes_size(14, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.label.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.is_default_value {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.int_value {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.string_value.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.boolean_value {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.tristate_value {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.string_list_value {
                os.write_string(6, &v)?;
            };
            if let Some(v) = self.license.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            for v in &self.string_dict_value {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            for v in &self.fileset_list_value {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            };
            for v in &self.label_list_dict_value {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            };
            for v in &self.string_list_dict_value {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            for v in &self.int_list_value {
                os.write_int32(13, *v)?;
            };
            for v in &self.label_dict_unary_value {
                ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
            };
            for v in &self.label_keyed_string_dict_value {
                ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
            };
            for v in &self.DEPRECATED_string_dict_unary_value {
                os.write_bytes(14, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SelectorEntry {
            SelectorEntry::new()
        }

        fn clear(&mut self) {
            self.label = ::std::option::Option::None;
            self.is_default_value = ::std::option::Option::None;
            self.int_value = ::std::option::Option::None;
            self.string_value = ::std::option::Option::None;
            self.boolean_value = ::std::option::Option::None;
            self.tristate_value = ::std::option::Option::None;
            self.string_list_value.clear();
            self.license.clear();
            self.string_dict_value.clear();
            self.fileset_list_value.clear();
            self.label_list_dict_value.clear();
            self.string_list_dict_value.clear();
            self.int_list_value.clear();
            self.label_dict_unary_value.clear();
            self.label_keyed_string_dict_value.clear();
            self.DEPRECATED_string_dict_unary_value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SelectorEntry {
            static instance: SelectorEntry = SelectorEntry {
                label: ::std::option::Option::None,
                is_default_value: ::std::option::Option::None,
                int_value: ::std::option::Option::None,
                string_value: ::std::option::Option::None,
                boolean_value: ::std::option::Option::None,
                tristate_value: ::std::option::Option::None,
                string_list_value: ::std::vec::Vec::new(),
                license: ::protobuf::MessageField::none(),
                string_dict_value: ::std::vec::Vec::new(),
                fileset_list_value: ::std::vec::Vec::new(),
                label_list_dict_value: ::std::vec::Vec::new(),
                string_list_dict_value: ::std::vec::Vec::new(),
                int_list_value: ::std::vec::Vec::new(),
                label_dict_unary_value: ::std::vec::Vec::new(),
                label_keyed_string_dict_value: ::std::vec::Vec::new(),
                DEPRECATED_string_dict_unary_value: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SelectorEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Attribute.SelectorEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SelectorEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SelectorEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:blaze_query.Attribute.Selector)
    pub struct Selector {
        // message fields
        // @@protoc_insertion_point(field:blaze_query.Attribute.Selector.entries)
        pub entries: ::std::vec::Vec<SelectorEntry>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.Selector.has_default_value)
        pub has_default_value: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.Selector.no_match_error)
        pub no_match_error: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:blaze_query.Attribute.Selector.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Selector {
        fn default() -> &'a Selector {
            <Selector as ::protobuf::Message>::default_instance()
        }
    }

    impl Selector {
        pub fn new() -> Selector {
            ::std::default::Default::default()
        }

        // optional bool has_default_value = 2;

        pub fn has_default_value(&self) -> bool {
            self.has_default_value.unwrap_or(false)
        }

        pub fn clear_has_default_value(&mut self) {
            self.has_default_value = ::std::option::Option::None;
        }

        pub fn has_has_default_value(&self) -> bool {
            self.has_default_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_default_value(&mut self, v: bool) {
            self.has_default_value = ::std::option::Option::Some(v);
        }

        // optional string no_match_error = 3;

        pub fn no_match_error(&self) -> &str {
            match self.no_match_error.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_no_match_error(&mut self) {
            self.no_match_error = ::std::option::Option::None;
        }

        pub fn has_no_match_error(&self) -> bool {
            self.no_match_error.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_match_error(&mut self, v: ::std::string::String) {
            self.no_match_error = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_no_match_error(&mut self) -> &mut ::std::string::String {
            if self.no_match_error.is_none() {
                self.no_match_error = ::std::option::Option::Some(::std::string::String::new());
            }
            self.no_match_error.as_mut().unwrap()
        }

        // Take field
        pub fn take_no_match_error(&mut self) -> ::std::string::String {
            self.no_match_error.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "entries",
                |m: &Selector| { &m.entries },
                |m: &mut Selector| { &mut m.entries },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_default_value",
                |m: &Selector| { &m.has_default_value },
                |m: &mut Selector| { &mut m.has_default_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "no_match_error",
                |m: &Selector| { &m.no_match_error },
                |m: &mut Selector| { &mut m.no_match_error },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Selector>(
                "Attribute.Selector",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Selector {
        const NAME: &'static str = "Selector";

        fn is_initialized(&self) -> bool {
            for v in &self.entries {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.entries.push(is.read_message()?);
                    },
                    16 => {
                        self.has_default_value = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.no_match_error = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.entries {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.has_default_value {
                my_size += 1 + 1;
            }
            if let Some(v) = self.no_match_error.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.entries {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.has_default_value {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.no_match_error.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Selector {
            Selector::new()
        }

        fn clear(&mut self) {
            self.entries.clear();
            self.has_default_value = ::std::option::Option::None;
            self.no_match_error = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Selector {
            static instance: Selector = Selector {
                entries: ::std::vec::Vec::new(),
                has_default_value: ::std::option::Option::None,
                no_match_error: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Selector {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Attribute.Selector").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Selector {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Selector {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:blaze_query.Attribute.SelectorList)
    pub struct SelectorList {
        // message fields
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorList.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<Discriminator>>,
        // @@protoc_insertion_point(field:blaze_query.Attribute.SelectorList.elements)
        pub elements: ::std::vec::Vec<Selector>,
        // special fields
        // @@protoc_insertion_point(special_field:blaze_query.Attribute.SelectorList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SelectorList {
        fn default() -> &'a SelectorList {
            <SelectorList as ::protobuf::Message>::default_instance()
        }
    }

    impl SelectorList {
        pub fn new() -> SelectorList {
            ::std::default::Default::default()
        }

        // optional .blaze_query.Attribute.Discriminator type = 1;

        pub fn type_(&self) -> Discriminator {
            match self.type_ {
                Some(e) => e.enum_value_or(Discriminator::INTEGER),
                None => Discriminator::INTEGER,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: Discriminator) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &SelectorList| { &m.type_ },
                |m: &mut SelectorList| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "elements",
                |m: &SelectorList| { &m.elements },
                |m: &mut SelectorList| { &mut m.elements },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectorList>(
                "Attribute.SelectorList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SelectorList {
        const NAME: &'static str = "SelectorList";

        fn is_initialized(&self) -> bool {
            for v in &self.elements {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.elements.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            for value in &self.elements {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.elements {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SelectorList {
            SelectorList::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.elements.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SelectorList {
            static instance: SelectorList = SelectorList {
                type_: ::std::option::Option::None,
                elements: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SelectorList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Attribute.SelectorList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SelectorList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SelectorList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:blaze_query.Attribute.Discriminator)
    pub enum Discriminator {
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.INTEGER)
        INTEGER = 1,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.STRING)
        STRING = 2,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.LABEL)
        LABEL = 3,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.OUTPUT)
        OUTPUT = 4,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.STRING_LIST)
        STRING_LIST = 5,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.LABEL_LIST)
        LABEL_LIST = 6,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.OUTPUT_LIST)
        OUTPUT_LIST = 7,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.DISTRIBUTION_SET)
        DISTRIBUTION_SET = 8,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.LICENSE)
        LICENSE = 9,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.STRING_DICT)
        STRING_DICT = 10,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.FILESET_ENTRY_LIST)
        FILESET_ENTRY_LIST = 11,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.LABEL_LIST_DICT)
        LABEL_LIST_DICT = 12,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.STRING_LIST_DICT)
        STRING_LIST_DICT = 13,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.BOOLEAN)
        BOOLEAN = 14,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.TRISTATE)
        TRISTATE = 15,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.INTEGER_LIST)
        INTEGER_LIST = 16,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.UNKNOWN)
        UNKNOWN = 18,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.LABEL_DICT_UNARY)
        LABEL_DICT_UNARY = 19,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.SELECTOR_LIST)
        SELECTOR_LIST = 20,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.LABEL_KEYED_STRING_DICT)
        LABEL_KEYED_STRING_DICT = 21,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Discriminator.DEPRECATED_STRING_DICT_UNARY)
        DEPRECATED_STRING_DICT_UNARY = 17,
    }

    impl ::protobuf::Enum for Discriminator {
        const NAME: &'static str = "Discriminator";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Discriminator> {
            match value {
                1 => ::std::option::Option::Some(Discriminator::INTEGER),
                2 => ::std::option::Option::Some(Discriminator::STRING),
                3 => ::std::option::Option::Some(Discriminator::LABEL),
                4 => ::std::option::Option::Some(Discriminator::OUTPUT),
                5 => ::std::option::Option::Some(Discriminator::STRING_LIST),
                6 => ::std::option::Option::Some(Discriminator::LABEL_LIST),
                7 => ::std::option::Option::Some(Discriminator::OUTPUT_LIST),
                8 => ::std::option::Option::Some(Discriminator::DISTRIBUTION_SET),
                9 => ::std::option::Option::Some(Discriminator::LICENSE),
                10 => ::std::option::Option::Some(Discriminator::STRING_DICT),
                11 => ::std::option::Option::Some(Discriminator::FILESET_ENTRY_LIST),
                12 => ::std::option::Option::Some(Discriminator::LABEL_LIST_DICT),
                13 => ::std::option::Option::Some(Discriminator::STRING_LIST_DICT),
                14 => ::std::option::Option::Some(Discriminator::BOOLEAN),
                15 => ::std::option::Option::Some(Discriminator::TRISTATE),
                16 => ::std::option::Option::Some(Discriminator::INTEGER_LIST),
                18 => ::std::option::Option::Some(Discriminator::UNKNOWN),
                19 => ::std::option::Option::Some(Discriminator::LABEL_DICT_UNARY),
                20 => ::std::option::Option::Some(Discriminator::SELECTOR_LIST),
                21 => ::std::option::Option::Some(Discriminator::LABEL_KEYED_STRING_DICT),
                17 => ::std::option::Option::Some(Discriminator::DEPRECATED_STRING_DICT_UNARY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Discriminator] = &[
            Discriminator::INTEGER,
            Discriminator::STRING,
            Discriminator::LABEL,
            Discriminator::OUTPUT,
            Discriminator::STRING_LIST,
            Discriminator::LABEL_LIST,
            Discriminator::OUTPUT_LIST,
            Discriminator::DISTRIBUTION_SET,
            Discriminator::LICENSE,
            Discriminator::STRING_DICT,
            Discriminator::FILESET_ENTRY_LIST,
            Discriminator::LABEL_LIST_DICT,
            Discriminator::STRING_LIST_DICT,
            Discriminator::BOOLEAN,
            Discriminator::TRISTATE,
            Discriminator::INTEGER_LIST,
            Discriminator::UNKNOWN,
            Discriminator::LABEL_DICT_UNARY,
            Discriminator::SELECTOR_LIST,
            Discriminator::LABEL_KEYED_STRING_DICT,
            Discriminator::DEPRECATED_STRING_DICT_UNARY,
        ];
    }

    impl ::protobuf::EnumFull for Discriminator {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Attribute.Discriminator").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Discriminator::INTEGER => 0,
                Discriminator::STRING => 1,
                Discriminator::LABEL => 2,
                Discriminator::OUTPUT => 3,
                Discriminator::STRING_LIST => 4,
                Discriminator::LABEL_LIST => 5,
                Discriminator::OUTPUT_LIST => 6,
                Discriminator::DISTRIBUTION_SET => 7,
                Discriminator::LICENSE => 8,
                Discriminator::STRING_DICT => 9,
                Discriminator::FILESET_ENTRY_LIST => 10,
                Discriminator::LABEL_LIST_DICT => 11,
                Discriminator::STRING_LIST_DICT => 12,
                Discriminator::BOOLEAN => 13,
                Discriminator::TRISTATE => 14,
                Discriminator::INTEGER_LIST => 15,
                Discriminator::UNKNOWN => 16,
                Discriminator::LABEL_DICT_UNARY => 17,
                Discriminator::SELECTOR_LIST => 18,
                Discriminator::LABEL_KEYED_STRING_DICT => 19,
                Discriminator::DEPRECATED_STRING_DICT_UNARY => 20,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Discriminator {
        fn default() -> Self {
            Discriminator::INTEGER
        }
    }

    impl Discriminator {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Discriminator>("Attribute.Discriminator")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:blaze_query.Attribute.Tristate)
    pub enum Tristate {
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Tristate.NO)
        NO = 0,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Tristate.YES)
        YES = 1,
        // @@protoc_insertion_point(enum_value:blaze_query.Attribute.Tristate.AUTO)
        AUTO = 2,
    }

    impl ::protobuf::Enum for Tristate {
        const NAME: &'static str = "Tristate";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Tristate> {
            match value {
                0 => ::std::option::Option::Some(Tristate::NO),
                1 => ::std::option::Option::Some(Tristate::YES),
                2 => ::std::option::Option::Some(Tristate::AUTO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Tristate] = &[
            Tristate::NO,
            Tristate::YES,
            Tristate::AUTO,
        ];
    }

    impl ::protobuf::EnumFull for Tristate {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Attribute.Tristate").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Tristate {
        fn default() -> Self {
            Tristate::NO
        }
    }

    impl Tristate {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Tristate>("Attribute.Tristate")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.Rule)
pub struct Rule {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.Rule.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.rule_class)
    pub rule_class: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.location)
    pub location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.attribute)
    pub attribute: ::std::vec::Vec<Attribute>,
    // @@protoc_insertion_point(field:blaze_query.Rule.rule_input)
    pub rule_input: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.configured_rule_input)
    pub configured_rule_input: ::std::vec::Vec<ConfiguredRuleInput>,
    // @@protoc_insertion_point(field:blaze_query.Rule.rule_output)
    pub rule_output: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.default_setting)
    pub default_setting: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.DEPRECATED_public_by_default)
    pub DEPRECATED_public_by_default: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.Rule.DEPRECATED_is_skylark)
    pub DEPRECATED_is_skylark: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.Rule.skylark_environment_hash_code)
    pub skylark_environment_hash_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.instantiation_stack)
    pub instantiation_stack: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.Rule.definition_stack)
    pub definition_stack: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.Rule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rule {
    fn default() -> &'a Rule {
        <Rule as ::protobuf::Message>::default_instance()
    }
}

impl Rule {
    pub fn new() -> Rule {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string rule_class = 2;

    pub fn rule_class(&self) -> &str {
        match self.rule_class.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rule_class(&mut self) {
        self.rule_class = ::std::option::Option::None;
    }

    pub fn has_rule_class(&self) -> bool {
        self.rule_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rule_class(&mut self, v: ::std::string::String) {
        self.rule_class = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_class(&mut self) -> &mut ::std::string::String {
        if self.rule_class.is_none() {
            self.rule_class = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rule_class.as_mut().unwrap()
    }

    // Take field
    pub fn take_rule_class(&mut self) -> ::std::string::String {
        self.rule_class.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string location = 3;

    pub fn location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool DEPRECATED_public_by_default = 9;

    pub fn DEPRECATED_public_by_default(&self) -> bool {
        self.DEPRECATED_public_by_default.unwrap_or(false)
    }

    pub fn clear_DEPRECATED_public_by_default(&mut self) {
        self.DEPRECATED_public_by_default = ::std::option::Option::None;
    }

    pub fn has_DEPRECATED_public_by_default(&self) -> bool {
        self.DEPRECATED_public_by_default.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_public_by_default(&mut self, v: bool) {
        self.DEPRECATED_public_by_default = ::std::option::Option::Some(v);
    }

    // optional bool DEPRECATED_is_skylark = 10;

    pub fn DEPRECATED_is_skylark(&self) -> bool {
        self.DEPRECATED_is_skylark.unwrap_or(false)
    }

    pub fn clear_DEPRECATED_is_skylark(&mut self) {
        self.DEPRECATED_is_skylark = ::std::option::Option::None;
    }

    pub fn has_DEPRECATED_is_skylark(&self) -> bool {
        self.DEPRECATED_is_skylark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_is_skylark(&mut self, v: bool) {
        self.DEPRECATED_is_skylark = ::std::option::Option::Some(v);
    }

    // optional string skylark_environment_hash_code = 12;

    pub fn skylark_environment_hash_code(&self) -> &str {
        match self.skylark_environment_hash_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_skylark_environment_hash_code(&mut self) {
        self.skylark_environment_hash_code = ::std::option::Option::None;
    }

    pub fn has_skylark_environment_hash_code(&self) -> bool {
        self.skylark_environment_hash_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skylark_environment_hash_code(&mut self, v: ::std::string::String) {
        self.skylark_environment_hash_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_skylark_environment_hash_code(&mut self) -> &mut ::std::string::String {
        if self.skylark_environment_hash_code.is_none() {
            self.skylark_environment_hash_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.skylark_environment_hash_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_skylark_environment_hash_code(&mut self) -> ::std::string::String {
        self.skylark_environment_hash_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Rule| { &m.name },
            |m: &mut Rule| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rule_class",
            |m: &Rule| { &m.rule_class },
            |m: &mut Rule| { &mut m.rule_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &Rule| { &m.location },
            |m: &mut Rule| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attribute",
            |m: &Rule| { &m.attribute },
            |m: &mut Rule| { &mut m.attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rule_input",
            |m: &Rule| { &m.rule_input },
            |m: &mut Rule| { &mut m.rule_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "configured_rule_input",
            |m: &Rule| { &m.configured_rule_input },
            |m: &mut Rule| { &mut m.configured_rule_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rule_output",
            |m: &Rule| { &m.rule_output },
            |m: &mut Rule| { &mut m.rule_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "default_setting",
            |m: &Rule| { &m.default_setting },
            |m: &mut Rule| { &mut m.default_setting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "DEPRECATED_public_by_default",
            |m: &Rule| { &m.DEPRECATED_public_by_default },
            |m: &mut Rule| { &mut m.DEPRECATED_public_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "DEPRECATED_is_skylark",
            |m: &Rule| { &m.DEPRECATED_is_skylark },
            |m: &mut Rule| { &mut m.DEPRECATED_is_skylark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skylark_environment_hash_code",
            |m: &Rule| { &m.skylark_environment_hash_code },
            |m: &mut Rule| { &mut m.skylark_environment_hash_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "instantiation_stack",
            |m: &Rule| { &m.instantiation_stack },
            |m: &mut Rule| { &mut m.instantiation_stack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "definition_stack",
            |m: &Rule| { &m.definition_stack },
            |m: &mut Rule| { &mut m.definition_stack },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rule>(
            "Rule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rule {
    const NAME: &'static str = "Rule";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.rule_class.is_none() {
            return false;
        }
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configured_rule_input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.rule_class = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.attribute.push(is.read_message()?);
                },
                42 => {
                    self.rule_input.push(is.read_string()?);
                },
                122 => {
                    self.configured_rule_input.push(is.read_message()?);
                },
                50 => {
                    self.rule_output.push(is.read_string()?);
                },
                58 => {
                    self.default_setting.push(is.read_string()?);
                },
                72 => {
                    self.DEPRECATED_public_by_default = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.DEPRECATED_is_skylark = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.skylark_environment_hash_code = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.instantiation_stack.push(is.read_string()?);
                },
                114 => {
                    self.definition_stack.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rule_class.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rule_input {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.configured_rule_input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rule_output {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.default_setting {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.DEPRECATED_public_by_default {
            my_size += 1 + 1;
        }
        if let Some(v) = self.DEPRECATED_is_skylark {
            my_size += 1 + 1;
        }
        if let Some(v) = self.skylark_environment_hash_code.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        for value in &self.instantiation_stack {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.definition_stack {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rule_class.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.attribute {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.rule_input {
            os.write_string(5, &v)?;
        };
        for v in &self.configured_rule_input {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.rule_output {
            os.write_string(6, &v)?;
        };
        for v in &self.default_setting {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.DEPRECATED_public_by_default {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.DEPRECATED_is_skylark {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.skylark_environment_hash_code.as_ref() {
            os.write_string(12, v)?;
        }
        for v in &self.instantiation_stack {
            os.write_string(13, &v)?;
        };
        for v in &self.definition_stack {
            os.write_string(14, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rule {
        Rule::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.rule_class = ::std::option::Option::None;
        self.location = ::std::option::Option::None;
        self.attribute.clear();
        self.rule_input.clear();
        self.configured_rule_input.clear();
        self.rule_output.clear();
        self.default_setting.clear();
        self.DEPRECATED_public_by_default = ::std::option::Option::None;
        self.DEPRECATED_is_skylark = ::std::option::Option::None;
        self.skylark_environment_hash_code = ::std::option::Option::None;
        self.instantiation_stack.clear();
        self.definition_stack.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rule {
        static instance: Rule = Rule {
            name: ::std::option::Option::None,
            rule_class: ::std::option::Option::None,
            location: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            rule_input: ::std::vec::Vec::new(),
            configured_rule_input: ::std::vec::Vec::new(),
            rule_output: ::std::vec::Vec::new(),
            default_setting: ::std::vec::Vec::new(),
            DEPRECATED_public_by_default: ::std::option::Option::None,
            DEPRECATED_is_skylark: ::std::option::Option::None,
            skylark_environment_hash_code: ::std::option::Option::None,
            instantiation_stack: ::std::vec::Vec::new(),
            definition_stack: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.ConfiguredRuleInput)
pub struct ConfiguredRuleInput {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.ConfiguredRuleInput.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.ConfiguredRuleInput.configuration_checksum)
    pub configuration_checksum: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.ConfiguredRuleInput.configuration_id)
    pub configuration_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.ConfiguredRuleInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfiguredRuleInput {
    fn default() -> &'a ConfiguredRuleInput {
        <ConfiguredRuleInput as ::protobuf::Message>::default_instance()
    }
}

impl ConfiguredRuleInput {
    pub fn new() -> ConfiguredRuleInput {
        ::std::default::Default::default()
    }

    // optional string label = 1;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string configuration_checksum = 2;

    pub fn configuration_checksum(&self) -> &str {
        match self.configuration_checksum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configuration_checksum(&mut self) {
        self.configuration_checksum = ::std::option::Option::None;
    }

    pub fn has_configuration_checksum(&self) -> bool {
        self.configuration_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration_checksum(&mut self, v: ::std::string::String) {
        self.configuration_checksum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configuration_checksum(&mut self) -> &mut ::std::string::String {
        if self.configuration_checksum.is_none() {
            self.configuration_checksum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configuration_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_configuration_checksum(&mut self) -> ::std::string::String {
        self.configuration_checksum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 configuration_id = 3;

    pub fn configuration_id(&self) -> u32 {
        self.configuration_id.unwrap_or(0)
    }

    pub fn clear_configuration_id(&mut self) {
        self.configuration_id = ::std::option::Option::None;
    }

    pub fn has_configuration_id(&self) -> bool {
        self.configuration_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration_id(&mut self, v: u32) {
        self.configuration_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &ConfiguredRuleInput| { &m.label },
            |m: &mut ConfiguredRuleInput| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configuration_checksum",
            |m: &ConfiguredRuleInput| { &m.configuration_checksum },
            |m: &mut ConfiguredRuleInput| { &mut m.configuration_checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configuration_id",
            |m: &ConfiguredRuleInput| { &m.configuration_id },
            |m: &mut ConfiguredRuleInput| { &mut m.configuration_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfiguredRuleInput>(
            "ConfiguredRuleInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfiguredRuleInput {
    const NAME: &'static str = "ConfiguredRuleInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.configuration_checksum = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.configuration_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.configuration_checksum.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.configuration_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.label.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.configuration_checksum.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.configuration_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfiguredRuleInput {
        ConfiguredRuleInput::new()
    }

    fn clear(&mut self) {
        self.label = ::std::option::Option::None;
        self.configuration_checksum = ::std::option::Option::None;
        self.configuration_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfiguredRuleInput {
        static instance: ConfiguredRuleInput = ConfiguredRuleInput {
            label: ::std::option::Option::None,
            configuration_checksum: ::std::option::Option::None,
            configuration_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfiguredRuleInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfiguredRuleInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfiguredRuleInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfiguredRuleInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.RuleSummary)
pub struct RuleSummary {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.RuleSummary.rule)
    pub rule: ::protobuf::MessageField<Rule>,
    // @@protoc_insertion_point(field:blaze_query.RuleSummary.dependency)
    pub dependency: ::std::vec::Vec<Rule>,
    // @@protoc_insertion_point(field:blaze_query.RuleSummary.location)
    pub location: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.RuleSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuleSummary {
    fn default() -> &'a RuleSummary {
        <RuleSummary as ::protobuf::Message>::default_instance()
    }
}

impl RuleSummary {
    pub fn new() -> RuleSummary {
        ::std::default::Default::default()
    }

    // optional string location = 3;

    pub fn location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rule>(
            "rule",
            |m: &RuleSummary| { &m.rule },
            |m: &mut RuleSummary| { &mut m.rule },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dependency",
            |m: &RuleSummary| { &m.dependency },
            |m: &mut RuleSummary| { &mut m.dependency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &RuleSummary| { &m.location },
            |m: &mut RuleSummary| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuleSummary>(
            "RuleSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuleSummary {
    const NAME: &'static str = "RuleSummary";

    fn is_initialized(&self) -> bool {
        if self.rule.is_none() {
            return false;
        }
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dependency {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rule)?;
                },
                18 => {
                    self.dependency.push(is.read_message()?);
                },
                26 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dependency {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rule.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dependency {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.location.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuleSummary {
        RuleSummary::new()
    }

    fn clear(&mut self) {
        self.rule.clear();
        self.dependency.clear();
        self.location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuleSummary {
        static instance: RuleSummary = RuleSummary {
            rule: ::protobuf::MessageField::none(),
            dependency: ::std::vec::Vec::new(),
            location: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuleSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuleSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuleSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuleSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.PackageGroup)
pub struct PackageGroup {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.PackageGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.PackageGroup.contained_package)
    pub contained_package: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.PackageGroup.included_package_group)
    pub included_package_group: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.PackageGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PackageGroup {
    fn default() -> &'a PackageGroup {
        <PackageGroup as ::protobuf::Message>::default_instance()
    }
}

impl PackageGroup {
    pub fn new() -> PackageGroup {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PackageGroup| { &m.name },
            |m: &mut PackageGroup| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contained_package",
            |m: &PackageGroup| { &m.contained_package },
            |m: &mut PackageGroup| { &mut m.contained_package },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "included_package_group",
            |m: &PackageGroup| { &m.included_package_group },
            |m: &mut PackageGroup| { &mut m.included_package_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PackageGroup>(
            "PackageGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PackageGroup {
    const NAME: &'static str = "PackageGroup";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.contained_package.push(is.read_string()?);
                },
                26 => {
                    self.included_package_group.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.contained_package {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.included_package_group {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.contained_package {
            os.write_string(2, &v)?;
        };
        for v in &self.included_package_group {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PackageGroup {
        PackageGroup::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.contained_package.clear();
        self.included_package_group.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PackageGroup {
        static instance: PackageGroup = PackageGroup {
            name: ::std::option::Option::None,
            contained_package: ::std::vec::Vec::new(),
            included_package_group: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PackageGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PackageGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PackageGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PackageGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.EnvironmentGroup)
pub struct EnvironmentGroup {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.EnvironmentGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.EnvironmentGroup.environment)
    pub environment: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.EnvironmentGroup.default)
    pub default: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.EnvironmentGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnvironmentGroup {
    fn default() -> &'a EnvironmentGroup {
        <EnvironmentGroup as ::protobuf::Message>::default_instance()
    }
}

impl EnvironmentGroup {
    pub fn new() -> EnvironmentGroup {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnvironmentGroup| { &m.name },
            |m: &mut EnvironmentGroup| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "environment",
            |m: &EnvironmentGroup| { &m.environment },
            |m: &mut EnvironmentGroup| { &mut m.environment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "default",
            |m: &EnvironmentGroup| { &m.default },
            |m: &mut EnvironmentGroup| { &mut m.default },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnvironmentGroup>(
            "EnvironmentGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnvironmentGroup {
    const NAME: &'static str = "EnvironmentGroup";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.environment.push(is.read_string()?);
                },
                26 => {
                    self.default.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.environment {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.default {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.environment {
            os.write_string(2, &v)?;
        };
        for v in &self.default {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnvironmentGroup {
        EnvironmentGroup::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.environment.clear();
        self.default.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnvironmentGroup {
        static instance: EnvironmentGroup = EnvironmentGroup {
            name: ::std::option::Option::None,
            environment: ::std::vec::Vec::new(),
            default: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnvironmentGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnvironmentGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnvironmentGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvironmentGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.SourceFile)
pub struct SourceFile {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.SourceFile.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.SourceFile.location)
    pub location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.SourceFile.subinclude)
    pub subinclude: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.SourceFile.package_group)
    pub package_group: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.SourceFile.visibility_label)
    pub visibility_label: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.SourceFile.feature)
    pub feature: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.SourceFile.license)
    pub license: ::protobuf::MessageField<License>,
    // @@protoc_insertion_point(field:blaze_query.SourceFile.package_contains_errors)
    pub package_contains_errors: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.SourceFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceFile {
    fn default() -> &'a SourceFile {
        <SourceFile as ::protobuf::Message>::default_instance()
    }
}

impl SourceFile {
    pub fn new() -> SourceFile {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string location = 2;

    pub fn location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool package_contains_errors = 9;

    pub fn package_contains_errors(&self) -> bool {
        self.package_contains_errors.unwrap_or(false)
    }

    pub fn clear_package_contains_errors(&mut self) {
        self.package_contains_errors = ::std::option::Option::None;
    }

    pub fn has_package_contains_errors(&self) -> bool {
        self.package_contains_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_contains_errors(&mut self, v: bool) {
        self.package_contains_errors = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &SourceFile| { &m.name },
            |m: &mut SourceFile| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &SourceFile| { &m.location },
            |m: &mut SourceFile| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subinclude",
            |m: &SourceFile| { &m.subinclude },
            |m: &mut SourceFile| { &mut m.subinclude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "package_group",
            |m: &SourceFile| { &m.package_group },
            |m: &mut SourceFile| { &mut m.package_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "visibility_label",
            |m: &SourceFile| { &m.visibility_label },
            |m: &mut SourceFile| { &mut m.visibility_label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "feature",
            |m: &SourceFile| { &m.feature },
            |m: &mut SourceFile| { &mut m.feature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, License>(
            "license",
            |m: &SourceFile| { &m.license },
            |m: &mut SourceFile| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_contains_errors",
            |m: &SourceFile| { &m.package_contains_errors },
            |m: &mut SourceFile| { &mut m.package_contains_errors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SourceFile>(
            "SourceFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SourceFile {
    const NAME: &'static str = "SourceFile";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.license {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.subinclude.push(is.read_string()?);
                },
                34 => {
                    self.package_group.push(is.read_string()?);
                },
                42 => {
                    self.visibility_label.push(is.read_string()?);
                },
                50 => {
                    self.feature.push(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.license)?;
                },
                72 => {
                    self.package_contains_errors = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.subinclude {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.package_group {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.visibility_label {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.feature {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.license.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.package_contains_errors {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.subinclude {
            os.write_string(3, &v)?;
        };
        for v in &self.package_group {
            os.write_string(4, &v)?;
        };
        for v in &self.visibility_label {
            os.write_string(5, &v)?;
        };
        for v in &self.feature {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.license.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.package_contains_errors {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceFile {
        SourceFile::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.location = ::std::option::Option::None;
        self.subinclude.clear();
        self.package_group.clear();
        self.visibility_label.clear();
        self.feature.clear();
        self.license.clear();
        self.package_contains_errors = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceFile {
        static instance: SourceFile = SourceFile {
            name: ::std::option::Option::None,
            location: ::std::option::Option::None,
            subinclude: ::std::vec::Vec::new(),
            package_group: ::std::vec::Vec::new(),
            visibility_label: ::std::vec::Vec::new(),
            feature: ::std::vec::Vec::new(),
            license: ::protobuf::MessageField::none(),
            package_contains_errors: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SourceFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.GeneratedFile)
pub struct GeneratedFile {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.GeneratedFile.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.GeneratedFile.generating_rule)
    pub generating_rule: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.GeneratedFile.location)
    pub location: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.GeneratedFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GeneratedFile {
    fn default() -> &'a GeneratedFile {
        <GeneratedFile as ::protobuf::Message>::default_instance()
    }
}

impl GeneratedFile {
    pub fn new() -> GeneratedFile {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string generating_rule = 2;

    pub fn generating_rule(&self) -> &str {
        match self.generating_rule.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_generating_rule(&mut self) {
        self.generating_rule = ::std::option::Option::None;
    }

    pub fn has_generating_rule(&self) -> bool {
        self.generating_rule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generating_rule(&mut self, v: ::std::string::String) {
        self.generating_rule = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generating_rule(&mut self) -> &mut ::std::string::String {
        if self.generating_rule.is_none() {
            self.generating_rule = ::std::option::Option::Some(::std::string::String::new());
        }
        self.generating_rule.as_mut().unwrap()
    }

    // Take field
    pub fn take_generating_rule(&mut self) -> ::std::string::String {
        self.generating_rule.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string location = 3;

    pub fn location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &GeneratedFile| { &m.name },
            |m: &mut GeneratedFile| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generating_rule",
            |m: &GeneratedFile| { &m.generating_rule },
            |m: &mut GeneratedFile| { &mut m.generating_rule },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &GeneratedFile| { &m.location },
            |m: &mut GeneratedFile| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GeneratedFile>(
            "GeneratedFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GeneratedFile {
    const NAME: &'static str = "GeneratedFile";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.generating_rule.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.generating_rule = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.generating_rule.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.generating_rule.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GeneratedFile {
        GeneratedFile::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.generating_rule = ::std::option::Option::None;
        self.location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GeneratedFile {
        static instance: GeneratedFile = GeneratedFile {
            name: ::std::option::Option::None,
            generating_rule: ::std::option::Option::None,
            location: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GeneratedFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GeneratedFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GeneratedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeneratedFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.Target)
pub struct Target {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.Target.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<target::Discriminator>>,
    // @@protoc_insertion_point(field:blaze_query.Target.rule)
    pub rule: ::protobuf::MessageField<Rule>,
    // @@protoc_insertion_point(field:blaze_query.Target.source_file)
    pub source_file: ::protobuf::MessageField<SourceFile>,
    // @@protoc_insertion_point(field:blaze_query.Target.generated_file)
    pub generated_file: ::protobuf::MessageField<GeneratedFile>,
    // @@protoc_insertion_point(field:blaze_query.Target.package_group)
    pub package_group: ::protobuf::MessageField<PackageGroup>,
    // @@protoc_insertion_point(field:blaze_query.Target.environment_group)
    pub environment_group: ::protobuf::MessageField<EnvironmentGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.Target.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Target {
    fn default() -> &'a Target {
        <Target as ::protobuf::Message>::default_instance()
    }
}

impl Target {
    pub fn new() -> Target {
        ::std::default::Default::default()
    }

    // required .blaze_query.Target.Discriminator type = 1;

    pub fn type_(&self) -> target::Discriminator {
        match self.type_ {
            Some(e) => e.enum_value_or(target::Discriminator::RULE),
            None => target::Discriminator::RULE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: target::Discriminator) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Target| { &m.type_ },
            |m: &mut Target| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rule>(
            "rule",
            |m: &Target| { &m.rule },
            |m: &mut Target| { &mut m.rule },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SourceFile>(
            "source_file",
            |m: &Target| { &m.source_file },
            |m: &mut Target| { &mut m.source_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GeneratedFile>(
            "generated_file",
            |m: &Target| { &m.generated_file },
            |m: &mut Target| { &mut m.generated_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PackageGroup>(
            "package_group",
            |m: &Target| { &m.package_group },
            |m: &mut Target| { &mut m.package_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EnvironmentGroup>(
            "environment_group",
            |m: &Target| { &m.environment_group },
            |m: &mut Target| { &mut m.environment_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Target>(
            "Target",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Target {
    const NAME: &'static str = "Target";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generated_file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.package_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.environment_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rule)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_file)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.generated_file)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.package_group)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.environment_group)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.source_file.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.generated_file.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.package_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.environment_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rule.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.source_file.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.generated_file.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.package_group.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.environment_group.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Target {
        Target::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rule.clear();
        self.source_file.clear();
        self.generated_file.clear();
        self.package_group.clear();
        self.environment_group.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Target {
        static instance: Target = Target {
            type_: ::std::option::Option::None,
            rule: ::protobuf::MessageField::none(),
            source_file: ::protobuf::MessageField::none(),
            generated_file: ::protobuf::MessageField::none(),
            package_group: ::protobuf::MessageField::none(),
            environment_group: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Target {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Target").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Target {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Target {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Target`
pub mod target {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:blaze_query.Target.Discriminator)
    pub enum Discriminator {
        // @@protoc_insertion_point(enum_value:blaze_query.Target.Discriminator.RULE)
        RULE = 1,
        // @@protoc_insertion_point(enum_value:blaze_query.Target.Discriminator.SOURCE_FILE)
        SOURCE_FILE = 2,
        // @@protoc_insertion_point(enum_value:blaze_query.Target.Discriminator.GENERATED_FILE)
        GENERATED_FILE = 3,
        // @@protoc_insertion_point(enum_value:blaze_query.Target.Discriminator.PACKAGE_GROUP)
        PACKAGE_GROUP = 4,
        // @@protoc_insertion_point(enum_value:blaze_query.Target.Discriminator.ENVIRONMENT_GROUP)
        ENVIRONMENT_GROUP = 5,
    }

    impl ::protobuf::Enum for Discriminator {
        const NAME: &'static str = "Discriminator";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Discriminator> {
            match value {
                1 => ::std::option::Option::Some(Discriminator::RULE),
                2 => ::std::option::Option::Some(Discriminator::SOURCE_FILE),
                3 => ::std::option::Option::Some(Discriminator::GENERATED_FILE),
                4 => ::std::option::Option::Some(Discriminator::PACKAGE_GROUP),
                5 => ::std::option::Option::Some(Discriminator::ENVIRONMENT_GROUP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Discriminator] = &[
            Discriminator::RULE,
            Discriminator::SOURCE_FILE,
            Discriminator::GENERATED_FILE,
            Discriminator::PACKAGE_GROUP,
            Discriminator::ENVIRONMENT_GROUP,
        ];
    }

    impl ::protobuf::EnumFull for Discriminator {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Target.Discriminator").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Discriminator::RULE => 0,
                Discriminator::SOURCE_FILE => 1,
                Discriminator::GENERATED_FILE => 2,
                Discriminator::PACKAGE_GROUP => 3,
                Discriminator::ENVIRONMENT_GROUP => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Discriminator {
        fn default() -> Self {
            Discriminator::RULE
        }
    }

    impl Discriminator {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Discriminator>("Target.Discriminator")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.QueryResult)
pub struct QueryResult {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.QueryResult.target)
    pub target: ::std::vec::Vec<Target>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.QueryResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryResult {
    fn default() -> &'a QueryResult {
        <QueryResult as ::protobuf::Message>::default_instance()
    }
}

impl QueryResult {
    pub fn new() -> QueryResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "target",
            |m: &QueryResult| { &m.target },
            |m: &mut QueryResult| { &mut m.target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryResult>(
            "QueryResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryResult {
    const NAME: &'static str = "QueryResult";

    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.target {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.target {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryResult {
        QueryResult::new()
    }

    fn clear(&mut self) {
        self.target.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryResult {
        static instance: QueryResult = QueryResult {
            target: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.AllowedRuleClassInfo)
pub struct AllowedRuleClassInfo {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.AllowedRuleClassInfo.policy)
    pub policy: ::std::option::Option<::protobuf::EnumOrUnknown<allowed_rule_class_info::AllowedRuleClasses>>,
    // @@protoc_insertion_point(field:blaze_query.AllowedRuleClassInfo.allowed_rule_class)
    pub allowed_rule_class: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.AllowedRuleClassInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllowedRuleClassInfo {
    fn default() -> &'a AllowedRuleClassInfo {
        <AllowedRuleClassInfo as ::protobuf::Message>::default_instance()
    }
}

impl AllowedRuleClassInfo {
    pub fn new() -> AllowedRuleClassInfo {
        ::std::default::Default::default()
    }

    // required .blaze_query.AllowedRuleClassInfo.AllowedRuleClasses policy = 1;

    pub fn policy(&self) -> allowed_rule_class_info::AllowedRuleClasses {
        match self.policy {
            Some(e) => e.enum_value_or(allowed_rule_class_info::AllowedRuleClasses::ANY),
            None => allowed_rule_class_info::AllowedRuleClasses::ANY,
        }
    }

    pub fn clear_policy(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: allowed_rule_class_info::AllowedRuleClasses) {
        self.policy = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "policy",
            |m: &AllowedRuleClassInfo| { &m.policy },
            |m: &mut AllowedRuleClassInfo| { &mut m.policy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allowed_rule_class",
            |m: &AllowedRuleClassInfo| { &m.allowed_rule_class },
            |m: &mut AllowedRuleClassInfo| { &mut m.allowed_rule_class },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllowedRuleClassInfo>(
            "AllowedRuleClassInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllowedRuleClassInfo {
    const NAME: &'static str = "AllowedRuleClassInfo";

    fn is_initialized(&self) -> bool {
        if self.policy.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.policy = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.allowed_rule_class.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.policy {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.allowed_rule_class {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.policy {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.allowed_rule_class {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllowedRuleClassInfo {
        AllowedRuleClassInfo::new()
    }

    fn clear(&mut self) {
        self.policy = ::std::option::Option::None;
        self.allowed_rule_class.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllowedRuleClassInfo {
        static instance: AllowedRuleClassInfo = AllowedRuleClassInfo {
            policy: ::std::option::Option::None,
            allowed_rule_class: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllowedRuleClassInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllowedRuleClassInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllowedRuleClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowedRuleClassInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AllowedRuleClassInfo`
pub mod allowed_rule_class_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:blaze_query.AllowedRuleClassInfo.AllowedRuleClasses)
    pub enum AllowedRuleClasses {
        // @@protoc_insertion_point(enum_value:blaze_query.AllowedRuleClassInfo.AllowedRuleClasses.ANY)
        ANY = 1,
        // @@protoc_insertion_point(enum_value:blaze_query.AllowedRuleClassInfo.AllowedRuleClasses.SPECIFIED)
        SPECIFIED = 2,
    }

    impl ::protobuf::Enum for AllowedRuleClasses {
        const NAME: &'static str = "AllowedRuleClasses";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AllowedRuleClasses> {
            match value {
                1 => ::std::option::Option::Some(AllowedRuleClasses::ANY),
                2 => ::std::option::Option::Some(AllowedRuleClasses::SPECIFIED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AllowedRuleClasses] = &[
            AllowedRuleClasses::ANY,
            AllowedRuleClasses::SPECIFIED,
        ];
    }

    impl ::protobuf::EnumFull for AllowedRuleClasses {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AllowedRuleClassInfo.AllowedRuleClasses").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                AllowedRuleClasses::ANY => 0,
                AllowedRuleClasses::SPECIFIED => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for AllowedRuleClasses {
        fn default() -> Self {
            AllowedRuleClasses::ANY
        }
    }

    impl AllowedRuleClasses {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AllowedRuleClasses>("AllowedRuleClassInfo.AllowedRuleClasses")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.AttributeDefinition)
pub struct AttributeDefinition {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<attribute::Discriminator>>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.mandatory)
    pub mandatory: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.allowed_rule_classes)
    pub allowed_rule_classes: ::protobuf::MessageField<AllowedRuleClassInfo>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.documentation)
    pub documentation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.allow_empty)
    pub allow_empty: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.allow_single_file)
    pub allow_single_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.default)
    pub default: ::protobuf::MessageField<AttributeValue>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.executable)
    pub executable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.configurable)
    pub configurable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.nodep)
    pub nodep: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.AttributeDefinition.cfg_is_host)
    pub cfg_is_host: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.AttributeDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AttributeDefinition {
    fn default() -> &'a AttributeDefinition {
        <AttributeDefinition as ::protobuf::Message>::default_instance()
    }
}

impl AttributeDefinition {
    pub fn new() -> AttributeDefinition {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .blaze_query.Attribute.Discriminator type = 2;

    pub fn type_(&self) -> attribute::Discriminator {
        match self.type_ {
            Some(e) => e.enum_value_or(attribute::Discriminator::INTEGER),
            None => attribute::Discriminator::INTEGER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: attribute::Discriminator) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool mandatory = 3;

    pub fn mandatory(&self) -> bool {
        self.mandatory.unwrap_or(false)
    }

    pub fn clear_mandatory(&mut self) {
        self.mandatory = ::std::option::Option::None;
    }

    pub fn has_mandatory(&self) -> bool {
        self.mandatory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mandatory(&mut self, v: bool) {
        self.mandatory = ::std::option::Option::Some(v);
    }

    // optional string documentation = 5;

    pub fn documentation(&self) -> &str {
        match self.documentation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_documentation(&mut self) {
        self.documentation = ::std::option::Option::None;
    }

    pub fn has_documentation(&self) -> bool {
        self.documentation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        if self.documentation.is_none() {
            self.documentation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.documentation.as_mut().unwrap()
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        self.documentation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_empty = 6;

    pub fn allow_empty(&self) -> bool {
        self.allow_empty.unwrap_or(false)
    }

    pub fn clear_allow_empty(&mut self) {
        self.allow_empty = ::std::option::Option::None;
    }

    pub fn has_allow_empty(&self) -> bool {
        self.allow_empty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_empty(&mut self, v: bool) {
        self.allow_empty = ::std::option::Option::Some(v);
    }

    // optional bool allow_single_file = 7;

    pub fn allow_single_file(&self) -> bool {
        self.allow_single_file.unwrap_or(false)
    }

    pub fn clear_allow_single_file(&mut self) {
        self.allow_single_file = ::std::option::Option::None;
    }

    pub fn has_allow_single_file(&self) -> bool {
        self.allow_single_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_single_file(&mut self, v: bool) {
        self.allow_single_file = ::std::option::Option::Some(v);
    }

    // optional bool executable = 10;

    pub fn executable(&self) -> bool {
        self.executable.unwrap_or(false)
    }

    pub fn clear_executable(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_executable(&self) -> bool {
        self.executable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executable(&mut self, v: bool) {
        self.executable = ::std::option::Option::Some(v);
    }

    // optional bool configurable = 11;

    pub fn configurable(&self) -> bool {
        self.configurable.unwrap_or(false)
    }

    pub fn clear_configurable(&mut self) {
        self.configurable = ::std::option::Option::None;
    }

    pub fn has_configurable(&self) -> bool {
        self.configurable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configurable(&mut self, v: bool) {
        self.configurable = ::std::option::Option::Some(v);
    }

    // optional bool nodep = 12;

    pub fn nodep(&self) -> bool {
        self.nodep.unwrap_or(false)
    }

    pub fn clear_nodep(&mut self) {
        self.nodep = ::std::option::Option::None;
    }

    pub fn has_nodep(&self) -> bool {
        self.nodep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodep(&mut self, v: bool) {
        self.nodep = ::std::option::Option::Some(v);
    }

    // optional bool cfg_is_host = 13;

    pub fn cfg_is_host(&self) -> bool {
        self.cfg_is_host.unwrap_or(false)
    }

    pub fn clear_cfg_is_host(&mut self) {
        self.cfg_is_host = ::std::option::Option::None;
    }

    pub fn has_cfg_is_host(&self) -> bool {
        self.cfg_is_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cfg_is_host(&mut self, v: bool) {
        self.cfg_is_host = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &AttributeDefinition| { &m.name },
            |m: &mut AttributeDefinition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &AttributeDefinition| { &m.type_ },
            |m: &mut AttributeDefinition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mandatory",
            |m: &AttributeDefinition| { &m.mandatory },
            |m: &mut AttributeDefinition| { &mut m.mandatory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllowedRuleClassInfo>(
            "allowed_rule_classes",
            |m: &AttributeDefinition| { &m.allowed_rule_classes },
            |m: &mut AttributeDefinition| { &mut m.allowed_rule_classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "documentation",
            |m: &AttributeDefinition| { &m.documentation },
            |m: &mut AttributeDefinition| { &mut m.documentation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_empty",
            |m: &AttributeDefinition| { &m.allow_empty },
            |m: &mut AttributeDefinition| { &mut m.allow_empty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_single_file",
            |m: &AttributeDefinition| { &m.allow_single_file },
            |m: &mut AttributeDefinition| { &mut m.allow_single_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttributeValue>(
            "default",
            |m: &AttributeDefinition| { &m.default },
            |m: &mut AttributeDefinition| { &mut m.default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executable",
            |m: &AttributeDefinition| { &m.executable },
            |m: &mut AttributeDefinition| { &mut m.executable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configurable",
            |m: &AttributeDefinition| { &m.configurable },
            |m: &mut AttributeDefinition| { &mut m.configurable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodep",
            |m: &AttributeDefinition| { &m.nodep },
            |m: &mut AttributeDefinition| { &mut m.nodep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cfg_is_host",
            |m: &AttributeDefinition| { &m.cfg_is_host },
            |m: &mut AttributeDefinition| { &mut m.cfg_is_host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttributeDefinition>(
            "AttributeDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AttributeDefinition {
    const NAME: &'static str = "AttributeDefinition";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.type_.is_none() {
            return false;
        }
        for v in &self.allowed_rule_classes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.mandatory = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allowed_rule_classes)?;
                },
                42 => {
                    self.documentation = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.allow_empty = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.allow_single_file = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default)?;
                },
                80 => {
                    self.executable = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.configurable = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.nodep = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.cfg_is_host = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.mandatory {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allowed_rule_classes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.documentation.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.allow_empty {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_single_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.default.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.executable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.configurable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.nodep {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cfg_is_host {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mandatory {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.allowed_rule_classes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.documentation.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.allow_empty {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.allow_single_file {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.default.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.executable {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.configurable {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.nodep {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.cfg_is_host {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AttributeDefinition {
        AttributeDefinition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.mandatory = ::std::option::Option::None;
        self.allowed_rule_classes.clear();
        self.documentation = ::std::option::Option::None;
        self.allow_empty = ::std::option::Option::None;
        self.allow_single_file = ::std::option::Option::None;
        self.default.clear();
        self.executable = ::std::option::Option::None;
        self.configurable = ::std::option::Option::None;
        self.nodep = ::std::option::Option::None;
        self.cfg_is_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AttributeDefinition {
        static instance: AttributeDefinition = AttributeDefinition {
            name: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            mandatory: ::std::option::Option::None,
            allowed_rule_classes: ::protobuf::MessageField::none(),
            documentation: ::std::option::Option::None,
            allow_empty: ::std::option::Option::None,
            allow_single_file: ::std::option::Option::None,
            default: ::protobuf::MessageField::none(),
            executable: ::std::option::Option::None,
            configurable: ::std::option::Option::None,
            nodep: ::std::option::Option::None,
            cfg_is_host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AttributeDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AttributeDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AttributeDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.AttributeValue)
pub struct AttributeValue {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.AttributeValue.int)
    pub int: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:blaze_query.AttributeValue.string)
    pub string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.AttributeValue.bool)
    pub bool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:blaze_query.AttributeValue.list)
    pub list: ::std::vec::Vec<AttributeValue>,
    // @@protoc_insertion_point(field:blaze_query.AttributeValue.dict)
    pub dict: ::std::vec::Vec<attribute_value::DictEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.AttributeValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AttributeValue {
    fn default() -> &'a AttributeValue {
        <AttributeValue as ::protobuf::Message>::default_instance()
    }
}

impl AttributeValue {
    pub fn new() -> AttributeValue {
        ::std::default::Default::default()
    }

    // optional int32 int = 1;

    pub fn int(&self) -> i32 {
        self.int.unwrap_or(0)
    }

    pub fn clear_int(&mut self) {
        self.int = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        self.int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: i32) {
        self.int = ::std::option::Option::Some(v);
    }

    // optional string string = 2;

    pub fn string(&self) -> &str {
        match self.string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.string = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        self.string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if self.string.is_none() {
            self.string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string.as_mut().unwrap()
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        self.string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bool = 3;

    pub fn bool(&self) -> bool {
        self.bool.unwrap_or(false)
    }

    pub fn clear_bool(&mut self) {
        self.bool = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        self.bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.bool = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int",
            |m: &AttributeValue| { &m.int },
            |m: &mut AttributeValue| { &mut m.int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string",
            |m: &AttributeValue| { &m.string },
            |m: &mut AttributeValue| { &mut m.string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bool",
            |m: &AttributeValue| { &m.bool },
            |m: &mut AttributeValue| { &mut m.bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "list",
            |m: &AttributeValue| { &m.list },
            |m: &mut AttributeValue| { &mut m.list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dict",
            |m: &AttributeValue| { &m.dict },
            |m: &mut AttributeValue| { &mut m.dict },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttributeValue>(
            "AttributeValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AttributeValue {
    const NAME: &'static str = "AttributeValue";

    fn is_initialized(&self) -> bool {
        for v in &self.list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.int = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.string = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.bool = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.list.push(is.read_message()?);
                },
                42 => {
                    self.dict.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.int {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.bool {
            my_size += 1 + 1;
        }
        for value in &self.list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dict {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.int {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.string.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.bool {
            os.write_bool(3, v)?;
        }
        for v in &self.list {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.dict {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AttributeValue {
        AttributeValue::new()
    }

    fn clear(&mut self) {
        self.int = ::std::option::Option::None;
        self.string = ::std::option::Option::None;
        self.bool = ::std::option::Option::None;
        self.list.clear();
        self.dict.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AttributeValue {
        static instance: AttributeValue = AttributeValue {
            int: ::std::option::Option::None,
            string: ::std::option::Option::None,
            bool: ::std::option::Option::None,
            list: ::std::vec::Vec::new(),
            dict: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AttributeValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AttributeValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AttributeValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AttributeValue`
pub mod attribute_value {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:blaze_query.AttributeValue.DictEntry)
    pub struct DictEntry {
        // message fields
        // @@protoc_insertion_point(field:blaze_query.AttributeValue.DictEntry.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:blaze_query.AttributeValue.DictEntry.value)
        pub value: ::protobuf::MessageField<super::AttributeValue>,
        // special fields
        // @@protoc_insertion_point(special_field:blaze_query.AttributeValue.DictEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DictEntry {
        fn default() -> &'a DictEntry {
            <DictEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl DictEntry {
        pub fn new() -> DictEntry {
            ::std::default::Default::default()
        }

        // required string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &DictEntry| { &m.key },
                |m: &mut DictEntry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::AttributeValue>(
                "value",
                |m: &DictEntry| { &m.value },
                |m: &mut DictEntry| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DictEntry>(
                "AttributeValue.DictEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DictEntry {
        const NAME: &'static str = "DictEntry";

        fn is_initialized(&self) -> bool {
            if self.key.is_none() {
                return false;
            }
            if self.value.is_none() {
                return false;
            }
            for v in &self.value {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DictEntry {
            DictEntry::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DictEntry {
            static instance: DictEntry = DictEntry {
                key: ::std::option::Option::None,
                value: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DictEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("AttributeValue.DictEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DictEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DictEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.RuleDefinition)
pub struct RuleDefinition {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.RuleDefinition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.RuleDefinition.attribute)
    pub attribute: ::std::vec::Vec<AttributeDefinition>,
    // @@protoc_insertion_point(field:blaze_query.RuleDefinition.documentation)
    pub documentation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:blaze_query.RuleDefinition.label)
    pub label: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.RuleDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuleDefinition {
    fn default() -> &'a RuleDefinition {
        <RuleDefinition as ::protobuf::Message>::default_instance()
    }
}

impl RuleDefinition {
    pub fn new() -> RuleDefinition {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string documentation = 3;

    pub fn documentation(&self) -> &str {
        match self.documentation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_documentation(&mut self) {
        self.documentation = ::std::option::Option::None;
    }

    pub fn has_documentation(&self) -> bool {
        self.documentation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        if self.documentation.is_none() {
            self.documentation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.documentation.as_mut().unwrap()
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        self.documentation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 4;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &RuleDefinition| { &m.name },
            |m: &mut RuleDefinition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attribute",
            |m: &RuleDefinition| { &m.attribute },
            |m: &mut RuleDefinition| { &mut m.attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "documentation",
            |m: &RuleDefinition| { &m.documentation },
            |m: &mut RuleDefinition| { &mut m.documentation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &RuleDefinition| { &m.label },
            |m: &mut RuleDefinition| { &mut m.label },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuleDefinition>(
            "RuleDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuleDefinition {
    const NAME: &'static str = "RuleDefinition";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.attribute.push(is.read_message()?);
                },
                26 => {
                    self.documentation = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.documentation.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.attribute {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.documentation.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuleDefinition {
        RuleDefinition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.attribute.clear();
        self.documentation = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuleDefinition {
        static instance: RuleDefinition = RuleDefinition {
            name: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            documentation: ::std::option::Option::None,
            label: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuleDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuleDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuleDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuleDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:blaze_query.BuildLanguage)
pub struct BuildLanguage {
    // message fields
    // @@protoc_insertion_point(field:blaze_query.BuildLanguage.rule)
    pub rule: ::std::vec::Vec<RuleDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:blaze_query.BuildLanguage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildLanguage {
    fn default() -> &'a BuildLanguage {
        <BuildLanguage as ::protobuf::Message>::default_instance()
    }
}

impl BuildLanguage {
    pub fn new() -> BuildLanguage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rule",
            |m: &BuildLanguage| { &m.rule },
            |m: &mut BuildLanguage| { &mut m.rule },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildLanguage>(
            "BuildLanguage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildLanguage {
    const NAME: &'static str = "BuildLanguage";

    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rule.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rule {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildLanguage {
        BuildLanguage::new()
    }

    fn clear(&mut self) {
        self.rule.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildLanguage {
        static instance: BuildLanguage = BuildLanguage {
            rule: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildLanguage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildLanguage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildLanguage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dsrc/main/protobuf/build.proto\x12\x0bblaze_query\"J\n\x07License\
    \x12!\n\x0clicense_type\x18\x01\x20\x03(\tR\x0blicenseType\x12\x1c\n\tex\
    ception\x18\x02\x20\x03(\tR\texception\"9\n\x0fStringDictEntry\x12\x10\n\
    \x03key\x18\x01\x20\x02(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x02(\t\
    R\x05value\"=\n\x13LabelDictUnaryEntry\x12\x10\n\x03key\x18\x01\x20\x02(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x02(\tR\x05value\"<\n\x12Label\
    ListDictEntry\x12\x10\n\x03key\x18\x01\x20\x02(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x03(\tR\x05value\"C\n\x19LabelKeyedStringDictEntry\x12\
    \x10\n\x03key\x18\x01\x20\x02(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x02(\tR\x05value\"=\n\x13StringListDictEntry\x12\x10\n\x03key\x18\x01\
    \x20\x02(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x03(\tR\x05value\"\
    \xdb\x02\n\x0cFilesetEntry\x12\x16\n\x06source\x18\x01\x20\x02(\tR\x06so\
    urce\x123\n\x15destination_directory\x18\x02\x20\x02(\tR\x14destinationD\
    irectory\x12#\n\rfiles_present\x18\x07\x20\x01(\x08R\x0cfilesPresent\x12\
    \x12\n\x04file\x18\x03\x20\x03(\tR\x04file\x12\x18\n\x07exclude\x18\x04\
    \x20\x03(\tR\x07exclude\x12Z\n\x10symlink_behavior\x18\x05\x20\x01(\x0e2\
    ).blaze_query.FilesetEntry.SymlinkBehavior:\x04COPYR\x0fsymlinkBehavior\
    \x12!\n\x0cstrip_prefix\x18\x06\x20\x01(\tR\x0bstripPrefix\",\n\x0fSymli\
    nkBehavior\x12\x08\n\x04COPY\x10\x01\x12\x0f\n\x0bDEREFERENCE\x10\x02\"\
    \x9f\x16\n\tAttribute\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x121\
    \n\x14explicitly_specified\x18\r\x20\x01(\x08R\x13explicitlySpecified\
    \x12\x14\n\x05nodep\x18\x14\x20\x01(\x08R\x05nodep\x128\n\x04type\x18\
    \x02\x20\x02(\x0e2$.blaze_query.Attribute.DiscriminatorR\x04type\x12\x1b\
    \n\tint_value\x18\x03\x20\x01(\x05R\x08intValue\x12!\n\x0cstring_value\
    \x18\x05\x20\x01(\tR\x0bstringValue\x12#\n\rboolean_value\x18\x0e\x20\
    \x01(\x08R\x0cbooleanValue\x12F\n\x0etristate_value\x18\x0f\x20\x01(\x0e\
    2\x1f.blaze_query.Attribute.TristateR\rtristateValue\x12*\n\x11string_li\
    st_value\x18\x06\x20\x03(\tR\x0fstringListValue\x12.\n\x07license\x18\
    \x07\x20\x01(\x0b2\x14.blaze_query.LicenseR\x07license\x12H\n\x11string_\
    dict_value\x18\x08\x20\x03(\x0b2\x1c.blaze_query.StringDictEntryR\x0fstr\
    ingDictValue\x12G\n\x12fileset_list_value\x18\t\x20\x03(\x0b2\x19.blaze_\
    query.FilesetEntryR\x10filesetListValue\x12R\n\x15label_list_dict_value\
    \x18\n\x20\x03(\x0b2\x1f.blaze_query.LabelListDictEntryR\x12labelListDic\
    tValue\x12U\n\x16string_list_dict_value\x18\x0b\x20\x03(\x0b2\x20.blaze_\
    query.StringListDictEntryR\x13stringListDictValue\x12$\n\x0eint_list_val\
    ue\x18\x11\x20\x03(\x05R\x0cintListValue\x12U\n\x16label_dict_unary_valu\
    e\x18\x13\x20\x03(\x0b2\x20.blaze_query.LabelDictUnaryEntryR\x13labelDic\
    tUnaryValue\x12h\n\x1dlabel_keyed_string_dict_value\x18\x16\x20\x03(\x0b\
    2&.blaze_query.LabelKeyedStringDictEntryR\x19labelKeyedStringDictValue\
    \x12H\n\rselector_list\x18\x15\x20\x01(\x0b2#.blaze_query.Attribute.Sele\
    ctorListR\x0cselectorList\x12J\n\"DEPRECATED_string_dict_unary_value\x18\
    \x12\x20\x03(\x0cR\x1eDEPRECATEDStringDictUnaryValue\x1a\xcf\x07\n\rSele\
    ctorEntry\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x12(\n\x10is_d\
    efault_value\x18\x10\x20\x01(\x08R\x0eisDefaultValue\x12\x1b\n\tint_valu\
    e\x18\x02\x20\x01(\x05R\x08intValue\x12!\n\x0cstring_value\x18\x03\x20\
    \x01(\tR\x0bstringValue\x12#\n\rboolean_value\x18\x04\x20\x01(\x08R\x0cb\
    ooleanValue\x12F\n\x0etristate_value\x18\x05\x20\x01(\x0e2\x1f.blaze_que\
    ry.Attribute.TristateR\rtristateValue\x12*\n\x11string_list_value\x18\
    \x06\x20\x03(\tR\x0fstringListValue\x12.\n\x07license\x18\x07\x20\x01(\
    \x0b2\x14.blaze_query.LicenseR\x07license\x12H\n\x11string_dict_value\
    \x18\x08\x20\x03(\x0b2\x1c.blaze_query.StringDictEntryR\x0fstringDictVal\
    ue\x12G\n\x12fileset_list_value\x18\t\x20\x03(\x0b2\x19.blaze_query.File\
    setEntryR\x10filesetListValue\x12R\n\x15label_list_dict_value\x18\n\x20\
    \x03(\x0b2\x1f.blaze_query.LabelListDictEntryR\x12labelListDictValue\x12\
    U\n\x16string_list_dict_value\x18\x0b\x20\x03(\x0b2\x20.blaze_query.Stri\
    ngListDictEntryR\x13stringListDictValue\x12$\n\x0eint_list_value\x18\r\
    \x20\x03(\x05R\x0cintListValue\x12U\n\x16label_dict_unary_value\x18\x0f\
    \x20\x03(\x0b2\x20.blaze_query.LabelDictUnaryEntryR\x13labelDictUnaryVal\
    ue\x12h\n\x1dlabel_keyed_string_dict_value\x18\x11\x20\x03(\x0b2&.blaze_\
    query.LabelKeyedStringDictEntryR\x19labelKeyedStringDictValue\x12J\n\"DE\
    PRECATED_string_dict_unary_value\x18\x0e\x20\x03(\x0cR\x1eDEPRECATEDStri\
    ngDictUnaryValueJ\x04\x08\x0c\x10\r\x1a\x9c\x01\n\x08Selector\x12>\n\x07\
    entries\x18\x01\x20\x03(\x0b2$.blaze_query.Attribute.SelectorEntryR\x07e\
    ntries\x12*\n\x11has_default_value\x18\x02\x20\x01(\x08R\x0fhasDefaultVa\
    lue\x12$\n\x0eno_match_error\x18\x03\x20\x01(\tR\x0cnoMatchError\x1a\x85\
    \x01\n\x0cSelectorList\x128\n\x04type\x18\x01\x20\x01(\x0e2$.blaze_query\
    .Attribute.DiscriminatorR\x04type\x12;\n\x08elements\x18\x02\x20\x03(\
    \x0b2\x1f.blaze_query.Attribute.SelectorR\x08elements\"\x8a\x03\n\rDiscr\
    iminator\x12\x0b\n\x07INTEGER\x10\x01\x12\n\n\x06STRING\x10\x02\x12\t\n\
    \x05LABEL\x10\x03\x12\n\n\x06OUTPUT\x10\x04\x12\x0f\n\x0bSTRING_LIST\x10\
    \x05\x12\x0e\n\nLABEL_LIST\x10\x06\x12\x0f\n\x0bOUTPUT_LIST\x10\x07\x12\
    \x14\n\x10DISTRIBUTION_SET\x10\x08\x12\x0b\n\x07LICENSE\x10\t\x12\x0f\n\
    \x0bSTRING_DICT\x10\n\x12\x16\n\x12FILESET_ENTRY_LIST\x10\x0b\x12\x13\n\
    \x0fLABEL_LIST_DICT\x10\x0c\x12\x14\n\x10STRING_LIST_DICT\x10\r\x12\x0b\
    \n\x07BOOLEAN\x10\x0e\x12\x0c\n\x08TRISTATE\x10\x0f\x12\x10\n\x0cINTEGER\
    _LIST\x10\x10\x12\x0b\n\x07UNKNOWN\x10\x12\x12\x14\n\x10LABEL_DICT_UNARY\
    \x10\x13\x12\x11\n\rSELECTOR_LIST\x10\x14\x12\x1b\n\x17LABEL_KEYED_STRIN\
    G_DICT\x10\x15\x12\x20\n\x1cDEPRECATED_STRING_DICT_UNARY\x10\x11\"%\n\
    \x08Tristate\x12\x06\n\x02NO\x10\0\x12\x07\n\x03YES\x10\x01\x12\x08\n\
    \x04AUTO\x10\x02J\x04\x08\x0c\x10\rJ\x04\x08\x10\x10\x11\"\xea\x04\n\x04\
    Rule\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x1d\n\nrule_class\
    \x18\x02\x20\x02(\tR\truleClass\x12\x1a\n\x08location\x18\x03\x20\x01(\t\
    R\x08location\x124\n\tattribute\x18\x04\x20\x03(\x0b2\x16.blaze_query.At\
    tributeR\tattribute\x12\x1d\n\nrule_input\x18\x05\x20\x03(\tR\truleInput\
    \x12T\n\x15configured_rule_input\x18\x0f\x20\x03(\x0b2\x20.blaze_query.C\
    onfiguredRuleInputR\x13configuredRuleInput\x12\x1f\n\x0brule_output\x18\
    \x06\x20\x03(\tR\nruleOutput\x12'\n\x0fdefault_setting\x18\x07\x20\x03(\
    \tR\x0edefaultSetting\x12?\n\x1cDEPRECATED_public_by_default\x18\t\x20\
    \x01(\x08R\x19DEPRECATEDPublicByDefault\x122\n\x15DEPRECATED_is_skylark\
    \x18\n\x20\x01(\x08R\x13DEPRECATEDIsSkylark\x12A\n\x1dskylark_environmen\
    t_hash_code\x18\x0c\x20\x01(\tR\x1askylarkEnvironmentHashCode\x12/\n\x13\
    instantiation_stack\x18\r\x20\x03(\tR\x12instantiationStack\x12)\n\x10de\
    finition_stack\x18\x0e\x20\x03(\tR\x0fdefinitionStackJ\x04\x08\x08\x10\t\
    J\x04\x08\x0b\x10\x0c\"\x8d\x01\n\x13ConfiguredRuleInput\x12\x14\n\x05la\
    bel\x18\x01\x20\x01(\tR\x05label\x125\n\x16configuration_checksum\x18\
    \x02\x20\x01(\tR\x15configurationChecksum\x12)\n\x10configuration_id\x18\
    \x03\x20\x01(\rR\x0fconfigurationId\"\x83\x01\n\x0bRuleSummary\x12%\n\
    \x04rule\x18\x01\x20\x02(\x0b2\x11.blaze_query.RuleR\x04rule\x121\n\ndep\
    endency\x18\x02\x20\x03(\x0b2\x11.blaze_query.RuleR\ndependency\x12\x1a\
    \n\x08location\x18\x03\x20\x01(\tR\x08location\"\x8b\x01\n\x0cPackageGro\
    up\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12+\n\x11contained_pac\
    kage\x18\x02\x20\x03(\tR\x10containedPackage\x124\n\x16included_package_\
    group\x18\x03\x20\x03(\tR\x14includedPackageGroupJ\x04\x08\x04\x10\x05\"\
    b\n\x10EnvironmentGroup\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\
    \x12\x20\n\x0benvironment\x18\x02\x20\x03(\tR\x0benvironment\x12\x18\n\
    \x07default\x18\x03\x20\x03(\tR\x07default\"\xb4\x02\n\nSourceFile\x12\
    \x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x1a\n\x08location\x18\x02\
    \x20\x01(\tR\x08location\x12\x1e\n\nsubinclude\x18\x03\x20\x03(\tR\nsubi\
    nclude\x12#\n\rpackage_group\x18\x04\x20\x03(\tR\x0cpackageGroup\x12)\n\
    \x10visibility_label\x18\x05\x20\x03(\tR\x0fvisibilityLabel\x12\x18\n\
    \x07feature\x18\x06\x20\x03(\tR\x07feature\x12.\n\x07license\x18\x08\x20\
    \x01(\x0b2\x14.blaze_query.LicenseR\x07license\x126\n\x17package_contain\
    s_errors\x18\t\x20\x01(\x08R\x15packageContainsErrorsJ\x04\x08\x07\x10\
    \x08\"h\n\rGeneratedFile\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\
    \x12'\n\x0fgenerating_rule\x18\x02\x20\x02(\tR\x0egeneratingRule\x12\x1a\
    \n\x08location\x18\x03\x20\x01(\tR\x08location\"\xd9\x03\n\x06Target\x12\
    5\n\x04type\x18\x01\x20\x02(\x0e2!.blaze_query.Target.DiscriminatorR\x04\
    type\x12%\n\x04rule\x18\x02\x20\x01(\x0b2\x11.blaze_query.RuleR\x04rule\
    \x128\n\x0bsource_file\x18\x03\x20\x01(\x0b2\x17.blaze_query.SourceFileR\
    \nsourceFile\x12A\n\x0egenerated_file\x18\x04\x20\x01(\x0b2\x1a.blaze_qu\
    ery.GeneratedFileR\rgeneratedFile\x12>\n\rpackage_group\x18\x05\x20\x01(\
    \x0b2\x19.blaze_query.PackageGroupR\x0cpackageGroup\x12J\n\x11environmen\
    t_group\x18\x06\x20\x01(\x0b2\x1d.blaze_query.EnvironmentGroupR\x10envir\
    onmentGroup\"h\n\rDiscriminator\x12\x08\n\x04RULE\x10\x01\x12\x0f\n\x0bS\
    OURCE_FILE\x10\x02\x12\x12\n\x0eGENERATED_FILE\x10\x03\x12\x11\n\rPACKAG\
    E_GROUP\x10\x04\x12\x15\n\x11ENVIRONMENT_GROUP\x10\x05\":\n\x0bQueryResu\
    lt\x12+\n\x06target\x18\x01\x20\x03(\x0b2\x13.blaze_query.TargetR\x06tar\
    get\"\xc0\x01\n\x14AllowedRuleClassInfo\x12L\n\x06policy\x18\x01\x20\x02\
    (\x0e24.blaze_query.AllowedRuleClassInfo.AllowedRuleClassesR\x06policy\
    \x12,\n\x12allowed_rule_class\x18\x02\x20\x03(\tR\x10allowedRuleClass\",\
    \n\x12AllowedRuleClasses\x12\x07\n\x03ANY\x10\x01\x12\r\n\tSPECIFIED\x10\
    \x02\"\xfa\x03\n\x13AttributeDefinition\x12\x12\n\x04name\x18\x01\x20\
    \x02(\tR\x04name\x128\n\x04type\x18\x02\x20\x02(\x0e2$.blaze_query.Attri\
    bute.DiscriminatorR\x04type\x12\x1c\n\tmandatory\x18\x03\x20\x01(\x08R\t\
    mandatory\x12S\n\x14allowed_rule_classes\x18\x04\x20\x01(\x0b2!.blaze_qu\
    ery.AllowedRuleClassInfoR\x12allowedRuleClasses\x12$\n\rdocumentation\
    \x18\x05\x20\x01(\tR\rdocumentation\x12\x1f\n\x0ballow_empty\x18\x06\x20\
    \x01(\x08R\nallowEmpty\x12*\n\x11allow_single_file\x18\x07\x20\x01(\x08R\
    \x0fallowSingleFile\x125\n\x07default\x18\t\x20\x01(\x0b2\x1b.blaze_quer\
    y.AttributeValueR\x07default\x12\x1e\n\nexecutable\x18\n\x20\x01(\x08R\n\
    executable\x12\"\n\x0cconfigurable\x18\x0b\x20\x01(\x08R\x0cconfigurable\
    \x12\x14\n\x05nodep\x18\x0c\x20\x01(\x08R\x05nodep\x12\x1e\n\x0bcfg_is_h\
    ost\x18\r\x20\x01(\x08R\tcfgIsHost\"\x8c\x02\n\x0eAttributeValue\x12\x10\
    \n\x03int\x18\x01\x20\x01(\x05R\x03int\x12\x16\n\x06string\x18\x02\x20\
    \x01(\tR\x06string\x12\x12\n\x04bool\x18\x03\x20\x01(\x08R\x04bool\x12/\
    \n\x04list\x18\x04\x20\x03(\x0b2\x1b.blaze_query.AttributeValueR\x04list\
    \x129\n\x04dict\x18\x05\x20\x03(\x0b2%.blaze_query.AttributeValue.DictEn\
    tryR\x04dict\x1aP\n\tDictEntry\x12\x10\n\x03key\x18\x01\x20\x02(\tR\x03k\
    ey\x121\n\x05value\x18\x02\x20\x02(\x0b2\x1b.blaze_query.AttributeValueR\
    \x05value\"\xa0\x01\n\x0eRuleDefinition\x12\x12\n\x04name\x18\x01\x20\
    \x02(\tR\x04name\x12>\n\tattribute\x18\x02\x20\x03(\x0b2\x20.blaze_query\
    .AttributeDefinitionR\tattribute\x12$\n\rdocumentation\x18\x03\x20\x01(\
    \tR\rdocumentation\x12\x14\n\x05label\x18\x04\x20\x01(\tR\x05label\"@\n\
    \rBuildLanguage\x12/\n\x04rule\x18\x01\x20\x03(\x0b2\x1b.blaze_query.Rul\
    eDefinitionR\x04ruleB6\n4com.google.devtools.build.lib.query2.proto.prot\
    o2api\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(26);
            messages.push(License::generated_message_descriptor_data());
            messages.push(StringDictEntry::generated_message_descriptor_data());
            messages.push(LabelDictUnaryEntry::generated_message_descriptor_data());
            messages.push(LabelListDictEntry::generated_message_descriptor_data());
            messages.push(LabelKeyedStringDictEntry::generated_message_descriptor_data());
            messages.push(StringListDictEntry::generated_message_descriptor_data());
            messages.push(FilesetEntry::generated_message_descriptor_data());
            messages.push(Attribute::generated_message_descriptor_data());
            messages.push(Rule::generated_message_descriptor_data());
            messages.push(ConfiguredRuleInput::generated_message_descriptor_data());
            messages.push(RuleSummary::generated_message_descriptor_data());
            messages.push(PackageGroup::generated_message_descriptor_data());
            messages.push(EnvironmentGroup::generated_message_descriptor_data());
            messages.push(SourceFile::generated_message_descriptor_data());
            messages.push(GeneratedFile::generated_message_descriptor_data());
            messages.push(Target::generated_message_descriptor_data());
            messages.push(QueryResult::generated_message_descriptor_data());
            messages.push(AllowedRuleClassInfo::generated_message_descriptor_data());
            messages.push(AttributeDefinition::generated_message_descriptor_data());
            messages.push(AttributeValue::generated_message_descriptor_data());
            messages.push(RuleDefinition::generated_message_descriptor_data());
            messages.push(BuildLanguage::generated_message_descriptor_data());
            messages.push(attribute::SelectorEntry::generated_message_descriptor_data());
            messages.push(attribute::Selector::generated_message_descriptor_data());
            messages.push(attribute::SelectorList::generated_message_descriptor_data());
            messages.push(attribute_value::DictEntry::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(fileset_entry::SymlinkBehavior::generated_enum_descriptor_data());
            enums.push(attribute::Discriminator::generated_enum_descriptor_data());
            enums.push(attribute::Tristate::generated_enum_descriptor_data());
            enums.push(target::Discriminator::generated_enum_descriptor_data());
            enums.push(allowed_rule_class_info::AllowedRuleClasses::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
